0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
0 
1 	
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 {
1 }
1 }
1 }
1 }
1 }
1 }
1 }
1 }
1 }
1 }
1 }
1 }
1 }
1 }
1 }
1 }
1 }
1 }
1 }
1 }
1 }
1 }
1 }
1 }
1 }
1 }
1 }
1 }
1 }
1 }
1 }
1 }
1 }
2   
2   
2  *
2  *
2  *
2 		
2 	{
2 	{
2 	{
2 	{
2 	{
2 	{
2 	{
2 	{
2 	{
2 	{
2 	}
2 	}
2 	}
2 	}
2 	}
2 	}
2 	}
2 	}
2 	}
2 	}
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 */
2 /*
2 /*
2 /*
2 /*
2 /*
2 /*
2 /*
2 /*
2 /*
2 /*
2 /*
2 /*
2 /*
2 /*
2 } 
2 };
2 };
3    
3  * 
3  * 
3  * 
3  * 
3  * 
3  */
3 			
3 			
3 			
3 		{
3 		{
3 		{
3 		{
3 		{
3 		{
3 		{
3 		{
3 		}
3 		}
3 		}
3 		}
3 		}
3 		}
3 		}
3 		}
3 		}
3 /* 
3 /* 
3 /* 
3 /* 
3 /* 
3 /* 
3 /* 
3 /* 
3 /* 
3 /* 
3 /* 
3 /* 
3 /* 
3 /* 
3 /* 
3 /* 
3 /*	
3 /*	
3 /*	
3 /*	
3 /*	
3 /*	
3 /*	
3 /*	
3 /*	
4     
4     
4     
4     
4     
4     
4     
4     
4     
4     
4     
4     
4     
4     
4     
4     
4     
4     
4     
4     
4     
4     
4     
4     
4     
4     
4     
4     
4     
4     
4     
4     
4     
4     
4     
4     
4     
4 			;
4 			{
4 			{
4 			{
4 			{
4 			}
4 			}
4 			}
4 			}
4 		{	
5      
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     {
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5     }
5  * UK
5 				{
5 				{
5 				{
5 				{
5 				}
5 				}
5 				}
5 				}
5 				}
5 #else
5 #else
5 #if 0
5 #if 0
5 #if 0
6       
6     */
6     */
6     */
6     */
6     */
6     */
6     */
6     */
6     */
6     /*
6     /*
6     /*
6     /*
6     { 
6     { 
6     } 
6     } 
6     } 
6     } 
6     } 
6     } 
6     } 
6     } 
6 				{ 
6 		else
6 		else
6 #endif
6 #endif
6 #endif
6 #endif
6 #endif
6 #endif
6 #endif
6 #endif
6 #endif
6 #endif
6 #endif
6 #endif
6 #endif
6 #endif
6 #endif
6 #endif
6 #endif
6 exitf:
6 exitf:
6 int i;
6 int i;
7 - = odd
7        
7      */
7     /* 
7     /* 
7     /* 
7     /* 
7     }  
7     }  
7 			else
7 			else
7 			j--;
7 char c;
8         
8         
8         
8         
8         
8         
8         
8         
8         
8         
8         
8         
8         
8         
8         
8         
8         
8         
8         
8         
8         
8        )
8     {   
8     else
8     else
8     else
8     else
8     else
8     else
8     else
8 				else
8 				else
8 		/* For
8 + = even
9         )
9         ;
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         {
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9         }
9     else 
9     else 
9   Element
9 	err = 0;
9 return 0;
10           
10          *
10          *
10         */
10         */
10         */
10         /*
10         /*
10         } 
10         } 
10         } 
10         } 
10         } 
10         } 
10         } 
10         } 
10     } else
10     i = 0;
10     i = 1;
10     i = 1;
10   #valence
10 	return 0;
10 d = double
10 s = single
10 t = triple
11          */
11         }  
11         }  
11         }  
11         }  
11     return;
11 				int *p;
11 			int tmp;
11 u = unknown
12             
12             
12             
12             
12             
12             
12             
12             
12             
12             
12             
12             
12             
12             
12             
12             
12             
12         }   
12         else
12         else
12         else
12         else
12         else
12         else
12         else
12         else
12         else
12         else
12         else
12         else
12     } else {
12     char *p;
12     char *q;
12     default:
12     ret = 0;
12     ret = 1;
12     ret = 1;
12  * Version 1
12 				if ( p )
12 			continue;
12 	ndigit = 0;
12 	return err;
12 } INCHI_TAG;
12 a = aromatic
13              
13              
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             {
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13             }
13         else 
13         else 
13     int k, i;
13     return 0;
13     return 0;
13     return 0;
13     return 0;
13     return 0;
13     return 0;
13     return 0;
13     return 0;
13     return 0;
13     return 0;
13     return 0;
13     return 0;
13     return 0;
13     return 0;
13     return 0;
13     return 0;
13     return 0;
13     return 0;
13     return r;
13 	icompnt = 0;
13 ? = undefined
13 =============
13 char cnum[8];
14             } 
14             } 
14             } 
14             } 
14             } 
14             } 
14             } 
14             } 
14             } 
14         break;
14         break;
14         break;
14         break;
14         break;
14         break;
14         break;
14         break;
14         break;
14         i = 0;
14         i = i;
14         int i;
14 			cano_num++;
14 			ndigit = 0;
14 		unum[i] = i;
14 	/* charge  */
14 	cano_num = 0;
14 	orig_num = 1;
14 } AUX_LBL_BIT;
14 } AUX_LBL_ORD;
14 b = bond type:
14 exit_function:
15                
15             }  
15             }  
15         *i = j;
15         case 1:
15         case 2:
15     /* Bonds */
15     Identifier 
15     return err;
15     return ret;
15     return ret;
15     return ret;
15   [.]i#iso_mass
15   +/-[charge>1]
15  * May 30, 2016
15 		/*  stereo */
15 ===============
16                 
16               ) 
16             }   
16             }			
16             else
16             else
16             else
16          stereo,
16         } else {
16         } else {
16         } else {
16         } else {
16         } else {
16         } else {
16         } else {
16         char *p;
16         default:
16         default:
16         default:
16         default:
16         default:
16         len = 0;
16         r = "e";
16     AL_AEQU_ORD,
16     AL_ANBR_ORD,
16     AL_ATMR_ORD,
16     AL_BNDR_ORD,
16     AL_CRV__ORD,
16     AL_FIXH_ORD,
16     AL_FIXN_ORD,
16     AL_GEQU_ORD,
16     AL_ISON_ORD,
16     AL_ISOT_ORD,
16     AL_NORM_ORD,
16     AL_REC__ORD,
16     AL_REVR_ORD,
16     AL_SP3I_ORD,
16     AL_SP3N_ORD,
16     AL_STER_ORD,
16     AL_VERS_ORD,
16     AL_XYZR_ORD,
16     cur_len = 0;
16     cur_len = 0;
16     cur_len = 0;
16     IL_ALLH_ORD,
16     IL_ATMS_ORD,
16     IL_CHRG_ORD,
16     IL_CONN_ORD,
16     IL_DBND_ORD,
16     IL_FIXH_ORD,
16     IL_FML__ORD,
16     IL_FMLF_ORD,
16     IL_HFIX_ORD,
16     IL_INVS_ORD,
16     IL_ISOT_ORD,
16     IL_PROT_ORD,
16     IL_REC__ORD,
16     IL_SP3S_ORD,
16     IL_STER_ORD,
16     IL_TRNS_ORD,
16     IL_TYPS_ORD,
16     IL_VERS_ORD,
16     IL_XCGA_ORD,
16     int tag_len;
16   [.]d[#of 2H>1]
16   [.]h[#of 1H>1]
16   [.]t[#of 3H>1]
16   meanings of h:
16 							 strbuf, 
16 		int j = i - 1;
16 		u = units2[i];
16 		u = units2[i];
16 } IDENT_LBL_BIT;
16 } IDENT_LBL_ORD;
16 ================
16 p = bond parity:
17                 ;
17                 ;
17                 {
17                 {
17                 {
17                 {
17                 {
17                 {
17                 {
17                 {
17                 {
17                 {
17                 {
17                 {
17                 {
17                 {
17                 {
17                 {
17                 {
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                 }
17                ) 
17             else 
17             else 
17             else 
17             else 
17             else 
17             else 
17             else 
17             else 
17             j ++;
17             j ++;
17             j ++;
17          fixed H,
17          isotopic
17         int nRet;
17         return 0;
17         return 0;
17         return 1;
17         return r;
17     *pTAB = "\n";
17     double coord;
17     return szTag;
17   number of atoms
17 								 strbuf, 
17 	int n1 = u1->na;
17 	int n2 = u2->na;
17 #include "mode.h"
17 #include <math.h>
18                 } 
18             } else
18             break;
18             break;
18             break;
18             break;
18             break;
18             break;
18             break;
18             break;
18             break;
18             break;
18             break;
18             break;
18             break;
18             break;
18             break;
18             break;
18             break;
18             break;
18             break;
18             break;
18             break;
18             break;
18             break;
18             break;
18             break;
18             break;
18         /*  sp2 */
18         /*  sp3 */
18         return -1;
18         return -1;
18     CleanOrigCoord
18     if ( is_beta )
18     int  bHasIsoH;
18     int  ind, inc;
18     len_bonds = 0;
18     pr.bFhTag = 0;
18     pr.bFhTag = 0;
18     WriteOrigAtoms
18     WriteOrigCoord
18  * The InChI Trust
18 				if ( b1 > b2 )
18 			cnum[0] = '\0';
18 		nunits2 = i + 1;
18 		unum[j+1] = tmp;
18 	int *unum = NULL;
18 #include <ctype.h>
18 {                 
19             case 0:
19             case 0:
19             case 0:
19             case 0:
19             case 0:
19             case 0:
19             case 0:
19             case 0:
19             case 0:
19             case 0:
19             case 0:
19             case 0:
19             case 0:
19         return ret;
19     case _IS_ERROR:
19     if ( bEmpty ) {
19     if ( ind < 0 ) 
19     if ( ind < 0 ) 
19     return cur_len;
19     return cur_len;
19     return cur_len;
19     return num_zer;
19 		if ( i < p->n-1 )
19 	cano_nums[0] = -1;
19 #include <stdlib.h>
19 #include <string.h>
20                 else
20                 else
20                 else
20             } else {
20             } else {
20             } else {
20             } else {
20             } else {
20             default:
20             default:
20             default:
20             default:
20             default:
20             default:
20             default:
20             default:
20             default:
20             default:
20             default:
20             default:
20             default:
20             default:
20             default:
20             default:
20             len = 0;
20             len = 1;
20         if ( num ) {
20         is_beta = 1;
20         switch( i ) 
20     if ( 0 == *i ) {
20     int is_beta = 0;
20     Local constants 
20     Local functions 
20     MOL_COORD szBuf;
20     Output AuxInfo: 
20     Output AuxInfo: 
20     pr.pINChISort = 
20     szGetTag( ... ) 
20  * Cambridge CB1 7US
20 			V3000Data	*v3000;
20 		int tmp = unum[i];
20 	for (i=0; i<n; i++)
20 #include "ichi_io.h"
20 } /* OutputINChI1 */
20 output_aux_info:    
20 repeat_INChI_output:
21                     {
21                     {
21                     {
21                     {
21                     {
21                     {
21                     {
21                     {
21                     {
21                     }
21                     }
21                     }
21                     }
21                     }
21                     }
21                     }
21                     }
21                     }
21                     }
21                     }
21                     }
21                     }
21                     }
21                     }
21                     }
21                     }
21                     }
21                     }
21             continue;
21             int nRet;
21             return 1;
21             return 1;
21             return 1;
21             return 1;
21             return 1;
21             return 1;
21             return 1;
21             return 1;
21             return 1;
21             return 1;
21         bOutputType =
21         if ( !nRet ) 
21         pErr = x_err;
21         return szTag;
21     /* Coordinates */
21     case _IS_WARNING:
21     char *pLF, *pTAB;
21     const char *pErr;
21     GetSaveOptLetters
21     if ( *bOverflow )
21     pr->tot_len  = 0;
21     pr->tot_len  = 0;
21     pr.bOverflow = 0;
21   = no parity (empty)
21  * 8 Cavendish Avenue
21 							 pOrigStruct, 
21 	compnt_nums[0] = -1;
21 	PolymerUnit *u=NULL;
21 #include "ichimain.h"
21 #include "ichimake.h"
21 #include "ichister.h"
22                     } 
22                 } else
22                 } else
22                 } else
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 break;
22                 j = i;
22                 j = i;
22             return -1;
22         if ( len_buf )
22         if ( lSdfId ) 
22         if ( pLF[0] ) 
22         if ( pLF[0] ) 
22         if ( pLF[0] ) 
22         Now print out 
22         num_trans = 0;
22         parity    = 0;
22         pErr = x_ferr;
22         pErr = x_warn;
22      /f/h   -  fixed-H
22     Aux Info constants
22     if ( nTag == 3 ) {
22     int  max_num_comp;
22     len_atoms = i = 0;
22     len_coord = i = 0;
22     nAtomsAllComp = 0;
22     str_LineEnd( ... )
22     switch ( bFrom ) {
22     switch( bError ) {
22 		c = strbuf->pStr[k];
22 	if ( NULL != units2 )
22 #undef MIN_BOND_LENGTH
23                 case 0:
23                 case 0:
23                 case 0:
23                 case 0:
23                 case 0:
23                 case 0:
23                 case 0:
23             /* Fix11 */
23             b_self = 0;
23             cur_len ++;
23             is_ok  = 1;
23             num_zer ++;
23            (b) ind < -1
23         /* Atoms /A: */
23         /*	Bonds /B: */
23         ; /* success */
23         ; /* success */
23         if ( j >= 0 ) {
23         len_buf += len;
23         szTag[0] = '{';
23     char szCurAtom[32];
23     const char *r = "";
23     int  bAlwaysOutput;
23     OutputINChI1( ... )
23     OutputINChI2( ... )
23 				/* list[j] > tmp */
23 			cnum[ndigit] = '\0';
23 			err = 2; goto exitf;
23 			unum[j+1] = unum[j];
23 		/* sort bond atoms */
23 		inchi_free( units2 );
23 	for (i=0; i<p->n; i++)
23 	for (i=0; i<p->n; i++)
23 	for (i=0; i<p->n; i++)
23 	for (i=0; i<p->n; i++)
23 	for (i=1; i<p->n; i++)
23 	int *cano_nums = NULL;
24                         
24                     {   
24                 } else {
24                 } else {
24                 } else {
24                 } else {
24                 } else {
24                 default:
24                 default:
24                 default:
24                 default:
24                 default:
24                 default:
24                 default:
24                 default:
24                 default:
24             /* charge */
24             /* parity */
24             if ( !nRet )
24             if ( len ) {
24             if ( len ) {
24             if ( val ) {
24          isotopic stereo
24         /* Plain text */
24         bCompExists = 0;
24         char let1, let2;
24         Output Aux Info 
24         pr->tot_len = 0;
24         pr->tot_len = 0;
24         pr->tot_len = 0;
24         szTag[1] = '\0';
24     if ( pOrigStruct ) {
24     if ( pr.bOverflow ) 
24     is  = pr.pINChISort;
24     str_LineStart( ... )
24  * or any later version.
24 							STRUCT_DATA *sd);
24 			if ( c=='\0' )	break;
24 		else if ( isdigit(c) )
24 		if ( u->nb > 2 )						
24 		u = units2[ unum[i] ];
24 	for (i=0; i<p->n; i++)	
24 	if ( err != 0 )								
24 repeat_INChI_Aux_output:
25                         {
25                         {
25                         {
25                         }
25                         }
25                         }
25                         }
25                         }
25                         }
25                         }
25                         }
25                         }
25                         }
25                         }
25                         }
25                         }
25                         }
25                     else 
25                 continue;
25                 return 1;
25                 return 1;
25                 return 1;
25                 return 1;
25                 return 1;
25                 return 1;
25                 return 1;
25                 return 1;
25                 return 1;
25                 return 1;
25                 return 1;
25                 return 2;
25                 return 2;
25                 return 2;
25                 return 3;
25                 return 7;
25             /*-- atoms */
25             /*  stereo */
25             /* radical */
25             /* success */
25             /* valence */
25             }            
25             return szTag;
25         /* stereo type */
25         len_atoms += len;
25         len_bonds += len;
25         pr->tot_len  = 0;
25         pr->tot_len  = 0;
25         switch( bType ) {
25         switch( bType ) {
25         switch( bType ) {
25     /* AuxInfo header  */
25     /* char szBuf[64]; */
25     /* removed protons */
25     FreeOrigStruct( ... )
25     int nEstLen, ret = 0;
25     MOL_COORD szCurCoord;
25     print_INCHI_local pr;
25     WriteOrigBonds( ... )
25 			orig_num = atoi(cnum);
25 		for (k=0; k<u->na; k++)
25 		for (k=0; k<u->nb; k++)
25 		for (k=0; k<u->nb; k++)
25 		if ( u->nb == 2 )						
25 	int *compnt_nums = NULL;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     break;
26                     int m;
26                     int m;
26                 if ( e ) {
26             case iiEq2INV:
26             case iiEq2INV:
26             case iiEq2INV:
26             case iiEq2ISO:
26             case iiEq2ISO:
26             case iiEq2ISO:
26             case iiEq2ISO:
26             case iiEq2ISO:
26             if ( i != 1 ) 
26             num_trans = 0;
26         switch ( bType ) {
26     *then_goto_repeat = 0;
26     /* zero termination */
26     if ( bNoStructLabels )
26     int  nNumMovedProtons;
26     szBuf[cur_len] = '\0';
26     szBuf[cur_len] = '\0';
26   ========================
26 			{err = 4; goto exitf; }
26 		{ err = 1; goto exitf; }
26 		{ err = 1; goto exitf; }
26 		{ err = 1; goto exitf; }
26 		{ err = 3; goto exitf; }
26 		if ( NULL == units2[i] )
26 typedef enum tagAuxLblBit 
26 typedef enum tagAuxLblOrd 
27                            
27                            
27                            
27                            
27                            
27                            
27                            
27                            
27                            
27                            
27                            
27                     ii = j;
27                     int kc;
27                 ind -= inc;
27                 last = len;
27             cur_len += len;
27             cur_len += len;
27             if ( j2 < j ) {
27             if ( parity ) {
27             pr->bFhTag = 0;
27         goto exit_function;
27         goto exit_function;
27         goto exit_function;
27         goto exit_function;
27         goto exit_function;
27         goto exit_function;
27         goto exit_function;
27         goto exit_function;
27         if ( bCompExists ) 
27     *i = j; /* next item */
27     bHasIsoH           = 0;
27     const char *szXmlLabel;
27     if ( pr->nSegmAction ) 
27     if ( then_goto_repeat )
27     INCHI_SORT   *is, *is2;
27     int bCurOption, ret, i;
27     nNumMovedProtons   = 0;
27     strcpy( szTag, "???" );
27 													  pOrigStruct,
27 			if ( c==';' )	icompnt++;
27 		for (i=1; i<nunits2; i++)
27 		for (k=0; k<2*u->nb; k++)
27 		for (k=0; k<u->na-1; k++)
27 		for (k=0; k<u->na-1; k++)
27 	if ( n1 > n2 )			return 1;
27 	int n = inchi_min(n1, n2);
27 	PolymerUnit **units2=NULL;
27 	pOrigStruct->v3000 = NULL;
27 const INCHI_TAG AuxLbl[] = 
27 typedef struct tagInchiTag 
28                     } else {
28                     } else {
28                     default:
28                     default:
28                 if ( is2 ) {
28             bond_parity = 0;
28             if ( i > fst ) {
28             pr->tot_len = 0;
28             pr->tot_len = 0;
28             pr->tot_len = 0;
28             pr->tot_len = 0;
28             pr->tot_len = 0;
28             pr->tot_len = 0;
28             switch( bEq2 ) {
28             switch( bEq2 ) {
28             switch( bEq2 ) {
28             switch( bEq2 ) {
28             switch( bEq2 ) {
28             switch( bEq2 ) {
28             switch( bEq2 ) {
28             switch( bEq2 ) {
28             switch( bEq2 ) {
28             switch( bEq2 ) {
28             switch( bEq2 ) {
28             switch( bEq2 ) {
28             switch( bEq2 ) {
28          pr->bTautomeric && 
28          pr->bTautomeric && 
28         /*  aux equ atoms */
28         /*  aux equ atoms */
28         lrtrim(szVal, &len);
28      /f/i/h -  never happens
28     char szVal[LEN_COORD+1];
28     int i, j, bit, num, len;
28     pr.nCurINChISegment ++; 
28 					u->blist[ 2*k ]		=	b2; 
28 					u->blist[ 2*k ]		=	b2; 
28 				inchi_free( units2[i] );
28 			{ err = 11; goto exitf; }
28 			if ( NULL != units2[i] )	
28 			int b1 = u->blist[ 2*k ];
28 		{ err = 2; goto exitf; }		
28 	/* Extensions of v. 1.05 */
28 	if ( n1 < n2 )			return -1;
28 	if ( NULL	== unum )								
28 repeat_INChI_Aux_Iso_output:
28 typedef enum tagIdentLblBit 
28 typedef enum tagIdentLblOrd 
28 w = undefined stereo, double
29                             }
29                             }
29                     continue;
29                     continue;
29                     continue;
29                     continue;
29                     continue;
29                     return 1;
29                     return 3;
29                     return 5;
29                     return 5;
29                     return 6;
29                     val = mw;
29                 len -= i-fst;
29             if ( i < last ) {
29             len_coord += len;
29             switch( bType ) {
29             switch( bType ) {
29         /* Close INChI_Aux */
29         /*	Coordinates /C:	*/
29         goto output_aux_info;
29         pr->bFhTag = IL_FIXH;
29     } /* Aux info isotopic */
29     bINChIOutputOptions bits:
29     const char *szPlainLabel;
29     default: /*  _IS_FATAL */
29     int  intermediate_result;
29     int then_goto_repeat = 0;
29     pr.bAlways           = 0;
29     pr.bOmitRepetitions  = 1;
29     pr.bUseMulipliers    = 1;
29 		iisort( u->alist,  u->na );
29 	pOrigStruct->polymer = NULL;
29 #if ( CANON_FIXH_TRANS != 1 )
29 #if ( CANON_FIXH_TRANS == 1 )
29 const INCHI_TAG IdentLbl[] = 
30                             */
30                             */
30                             /*
30                             /*
30                         break;
30                         break;
30                         break;
30                         break;
30                         break;
30                         break;
30                         break;
30                         break;
30                         break;
30                         break;
30                     b_self ++;
30                     is_ok = 0;
30                 bCompExists++;
30                 case iiEq2ISO:
30                 case iiEq2ISO:
30                 case iiEq2ISO:
30                 case iiEq2ISO:
30                 case iiEq2ISO:
30                 if ( jj != j )
30                 if ( jj != j )
30                 if ( jj != j )
30                 if ( jj != j )
30                 if ( val > 0 )
30                 ii = TAUT_NON;
30                 ii = TAUT_NON;
30                 ii = TAUT_YES;
30                 len -= last-i;
30                 pr.bFhTag = 0;
30             bEq2 &= ~iiEq2INV;
30             bond_parityNM = 0;
30             case iiEq2NONTAUT:
30             case iiEq2NONTAUT:
30             case iiEq2NONTAUT:
30             case iiEq2NONTAUT:
30             case iiEq2NONTAUT:
30             if ( nTag != 2 ) {
30          pOrigStruct->szAtoms 
30          pr->bNonTautomeric ) 
30         *then_goto_repeat = 1;
30         /*-- aux tgroup equ */
30         return 0;  /* error */
30         szBuf[cur_len] = '\0';
30     /* end of INChI= output */
30     AL_REC_ = 1 << AL_REC__ORD
30     bEmbeddedOutputCalled = 0;
30     IL_REC_ = 1 << IL_REC__ORD
30     pr.bSecondNonTautPass = 0;
30     pr.nNumRemovedProtons = 0;
30 					u->blist[ 2*k+1 ]	=	b1; 	
30 					u->blist[ 2*k+1 ]	=	b1; 	
30 			cnum[ndigit] = c; ndigit++;
30 			int b2 = u->blist[ 2*k+1 ];
30 		else if ( u->nb == 1 )						
30 		pOrigStruct->szAtoms = NULL;
30 		pOrigStruct->szBonds = NULL;
30 		pOrigStruct->szCoord = NULL;
30 	/* Sort atoms in all units */
30 	inchi_strbuf_reset( strbuf );
30 	inchi_strbuf_reset( strbuf );
30 /* OUT_TN = OUT_T1 + OUT_NT */
30 <bonds> bpA;bpAbpA... </bonds>
30 A = neighbor orig. atom number
31                         } else 
31                     /* Fix12 */
31                     len = last;
31                   long lSdfId, 
31                   long lSdfId, 
31                 dec_pnt = last;
31                 if ( jj < 0 )  
31                 if ( num ++ ) {
31                 if ( val == 1 )
31               isotopic #2:  sp2
31               isotopic #3:  sp3
31             goto exit_function;
31             goto exit_function;
31             goto exit_function;
31             goto exit_function;
31             goto exit_function;
31             goto exit_function;
31             goto exit_function;
31             if ( bTag & bit ) {
31             if ( bTag & bit ) {
31             if ( tag_len > 0 ) 
31             nNeighOrder[0] = 0;
31          pr->bNonTautomeric && 
31         /* plain text output */
31         if ( at[j].p_parity ) {
31         if ( pr->nSegmAction ) 
31     /* Atoms */                
31     /* check buffer overflow */
31     AL_AEQU = 1 << AL_AEQU_ORD,
31     AL_ANBR = 1 << AL_ANBR_ORD,
31     AL_ATMR = 1 << AL_ATMR_ORD,
31     AL_BNDR = 1 << AL_BNDR_ORD,
31     AL_CRV_ = 1 << AL_CRV__ORD,
31     AL_FIXH = 1 << AL_FIXH_ORD,
31     AL_FIXN = 1 << AL_FIXN_ORD,
31     AL_GEQU = 1 << AL_GEQU_ORD,
31     AL_ISON = 1 << AL_ISON_ORD,
31     AL_ISOT = 1 << AL_ISOT_ORD,
31     AL_NORM = 1 << AL_NORM_ORD,
31     AL_REVR = 1 << AL_REVR_ORD,
31     AL_SP3I = 1 << AL_SP3I_ORD,
31     AL_SP3N = 1 << AL_SP3N_ORD,
31     AL_STER = 1 << AL_STER_ORD,
31     AL_VERS = 1 << AL_VERS_ORD,
31     AL_XYZR = 1 << AL_XYZR_ORD,
31     const char *szPlainComment;
31     for ( i = 0; i < 3; i ++ ) 
31     if ( pr->bIsotopic && !i &&
31     if ( pr.iCurTautMode < 0 ) 
31     IL_ALLH = 1 << IL_ALLH_ORD,
31     IL_ATMS = 1 << IL_ATMS_ORD,
31     IL_CHRG = 1 << IL_CHRG_ORD,
31     IL_CONN = 1 << IL_CONN_ORD,
31     IL_DBND = 1 << IL_DBND_ORD,
31     IL_FIXH = 1 << IL_FIXH_ORD,
31     IL_FML_ = 1 << IL_FML__ORD,
31     IL_FMLF = 1 << IL_FMLF_ORD,
31     IL_HFIX = 1 << IL_HFIX_ORD,
31     IL_INVS = 1 << IL_INVS_ORD,
31     IL_ISOT = 1 << IL_ISOT_ORD,
31     IL_PROT = 1 << IL_PROT_ORD,
31     IL_SP3S = 1 << IL_SP3S_ORD,
31     IL_STER = 1 << IL_STER_ORD,
31     IL_TRNS = 1 << IL_TRNS_ORD,
31     IL_TYPS = 1 << IL_TYPS_ORD,
31     IL_VERS = 1 << IL_VERS_ORD,
31     IL_XCGA = 1 << IL_XCGA_ORD,
31     inchi_ios_print( out_file, 
31     int bINChIOutputOptionsCur;
31     Output InChI: polymer layer
31 															 int *cano_nums,
31 			PolymerDescription *polymer;
31 #if ( EQL_H_NUM_TOGETHER == 1 )
32                         } else {
32                         } else {
32                         ii2 = j;
32                     last_pos --;
32                     last_pos --;
32                     last_pos --;
32                 if ( bCurTaut ) 
32                 pr->tot_len = 0;
32                 pr->tot_len = 0;
32                 pr->tot_len = 0;
32                 pr->tot_len = 0;
32                 switch( bEq2 ) {
32                 switch( bEq2 ) {
32                 switch( bEq2 ) {
32                 switch( bEq2 ) {
32                 switch( bEq2 ) {
32                 switch( bEq2 ) {
32                 switch( bEq2 ) {
32             /* isotopic shift */
32             k = nNeighOrder[kk];
32             pr.bFhTag = AL_FIXH;
32          *       Isotopic stereo
32         bFixTranspChargeBug = 1;
32         szVal[LEN_COORD] = '\0';
32     *i = num_inp_atoms>0? j : 0;
32     /* InChI output: isotopic */
32     /*	Find if it is isotopic */
32     AT_RANK nNeighOrder[MAXVAL];
32     Calculate equivalence mark 	
32     char szBuf[ORIG_STR_BUFLEN];
32     if ( pOrigStruct->szAtoms &&
32     if ( pOrigStruct->szBonds &&
32     int bFixTranspChargeBug = 0;
32     Output AuxInfo: stereo info 
32 								 char *pLF, char *pTAB )
32 													  &pr, pLF, pTAB );
32 			printf("%-d-", u->alist[k] );
32 	/* Prepare polymer substring */
32 	if ( NULL	== cano_nums )							
32 	int i, k, err = 0, nunits2 = 0;
32 #if ( ABC_CT_NUM_CLOSURES == 1 )
32 #if ( FIX_EMPTY_LAYER_BUG == 1 )
33                         continue;
33                         continue;
33                         continue;
33                         continue;
33                         continue;
33                         ii2 = -1;
33                     if ( jj < 0 )
33                 last = q - szVal;
33             if ( i == dec_pnt ) {
33             strcat( szTag, "}" );
33             strcpy( szVal, "0" );
33          && pOrigStruct->szBonds 
33         /*-- Isotopic symmetry */
33         goto repeat_INChI_output;
33         p = pOrigStruct->szAtoms;
33         p = pOrigStruct->szBonds;
33         p = pOrigStruct->szCoord;
33     } /* end of output AuxInfo */
33     if ( 0 < nTag && nTag < 3 ) {
33     if ( NULL==units2 )										
33     if (orig_inp_data->szCoord) {
33     inc                    =  -1;
33     inchi_strbuf_reset( strbuf );
33     inchi_strbuf_reset( strbuf );
33     inchi_strbuf_reset( strbuf );
33     inchi_strbuf_reset( strbuf );
33     ind                    =  -1;
33     int bEmpty= EquVal & iiEmpty;
33     int j, num_zer, len, cur_len;
33     pr.bAbcNumbers = bAbcNumbers;
33     pr.nCurINChISegment = DIFL_M;
33  * Originally developed at NIST. 
33 											print_INCHI_local *pr,
33 											print_INCHI_local *pr,
33 							char *szBuf, int buf_len);
33 							char *szBuf, int buf_len, 
33 		/* print bonds or just stars */
33 	if ( NULL	== compnt_nums )						
34                             } else
34                             break;
34                             break;
34                             break;
34                     if ( jj != j )
34                     if ( jj != j )
34                     if ( jj != j )
34                     ii = TAUT_NON;
34                     ii = TAUT_NON;
34                     ii = TAUT_YES;
34                     picur2nxt = k;
34                   int bAbcNumbers,
34                   int bAbcNumbers,
34                   int num_taut2[],
34                   int num_taut2[],
34                 case iiEq2NONTAUT:
34                 case iiEq2NONTAUT:
34                 case iiEq2NONTAUT:
34                 case iiEq2NONTAUT:
34                 case iiEq2NONTAUT:
34                 if ( chain_len ) {
34                 last_pos = length;
34                 last_pos = length;
34                 last_pos = length;
34                 pr.num_comp[j] ++;
34             /* verify neighbors */
34         /* AuxInfo: stereo data */
34         bEmbeddedOutputCalled = 0;
34         bEmbeddedOutputCalled = 1;
34         coord = strtod(szVal, &q);
34         if ( at[j].valence > 1 ) {
34         inchi_strbuf_reset( buf );
34         nRet = OutputINChI1( pCG, 
34     i =  pr->bSecondNonTautPass &&
34     Output AuxInfo: isotopic info 
34     pr.bFhTag                 = 0;
34 							 0 /*bDisconnectedCoord*/, 
34 									   print_INCHI_local *pr,
34 									   print_INCHI_local *pr,
34 															 int *compnt_nums )
34 																		 int *cano_nums,
34 																				 pr,cano_nums,
34 												print_INCHI_local *pr,
34 											int num_components2[], 
34 											int num_components2[], 
34 						INCHI_IOSTREAM_STRING *buf, 
34 			cano_nums[orig_num]	=	cano_num;
34 	if ( orig_inp_data->v3000 !=NULL)
34 #define MIN_BOND_LENGTH   (1.0e-6)
35                         /* Fix12 */
35                     chain_len2 = 0;
35                     chain_len2 = 0;
35                     if ( bCurIso ) 
35                     jj2 = ii2 = -1;
35                     pcur_atom = j2;
35                     picur2nxt = k2;
35                     val = mw + val;
35                   int bOutputType, 
35                   int bOutputType, 
35                 nNeighOrder[k] = k;
35             bStereoAbs[i]         =
35             case 0: /* main = ...*/
35             j2 = at[j].neighbor[k];
35             strcpy( szTag, "???" );
35          && pOrigStruct->szCoord ) 
35         if ( pOrigStruct->szAtoms )
35         if ( pOrigStruct->szBonds )
35         if ( pOrigStruct->szCoord )
35         inchi_ios_eprint(log_file, 
35         length = (int) strlen( p );
35         length = (int) strlen( p );
35         length = (int) strlen( p );
35         pr->bSecondNonTautPass = 1;
35         pr->tot_len = pr->tot_len2;
35         pr->tot_len = pr->tot_len2;
35         pr->tot_len = pr->tot_len2;
35     char *szErrorText = pErrorText;
35     if ( intermediate_result != 0 )
35     if ( intermediate_result != 0 )
35     if ( intermediate_result != 0 )
35     if ( intermediate_result != 0 )
35     if ( intermediate_result != 0 )
35     if ( intermediate_result != 0 )
35     if ( intermediate_result != 0 )
35     if ( intermediate_result != 0 )
35     if ( pr->bOutType == OUT_TN && 
35     if ( pr->bOutType == OUT_TN && 
35 							 pINChISortTautAndNonTaut2, 
35 																				 compnt_nums );
35 												int num_components2[], 
35 											char *pLF, char *pTAB );
35 											char *pLF, char *pTAB );
35 			compnt_nums[orig_num]	= icompnt;
35 			if ( u->blist[0] < u->blist[2] )
35 const char *EquString( int EquVal )
35 const char x_empty[]          = "";
36                             } else {
36                     bond_char = 'a';
36                     bond_char = 's';
36                     bond_char = 't';
36                     if ( bCurTaut ) 
36                     if ( bCurTaut ) 
36                 /* auxiliary info */
36                 /* floating point */
36                 /* to be sure...  */
36             /* no isotopic stereo */
36             bStereoAbsInverted[i] = 
36             if ( NUM_ISO_H(at,j) ) {
36             len = (int) (q - szVal);
36             switch ( pr.bOutType ) {
36         /* AuxInfo: isotopic info */
36         /* insert plain text tag if:
36         if ( pOrigStruct->szCoord &&
36         pr->iCurTautMode = TAUT_NON;
36     *obsolete* if ind >=0 XML output
36     /* AuxInfo normalization type */
36     if ( !pr->bSecondNonTautPass && 
36     INChI_Aux    *pINChI_Aux = NULL;
36     Output: words & additional tags 
36  * or e-mail to alan@inchi-trust.org
36 								 pINChISortTautAndNonTaut2, 
36 																				&pr, pLF, pTAB);
36 												char *pLF, char *pTAB );
36 										INCHI_IOSTREAM *out_file, 
36 										INCHI_IOSTREAM *out_file, 
36 										INCHI_IOSTREAM *out_file, 
36 						int ind, int bPlainTextTags );
36 	if ( NULL == cano_nums )		return 1;
36 	if ( orig_inp_data->polymer !=NULL 
36 	if ( unum )					inchi_free( unum );
36 #if ( REL_RAC_STEREO_IGN_1_SC == 1 )
36 #if ( REL_RAC_STEREO_IGN_1_SC == 1 )
36 #if ( REL_RAC_STEREO_IGN_1_SC == 1 )
36 #if ( REL_RAC_STEREO_IGN_1_SC == 1 )
36 const char a2p[]="ABCDEFGHIJKLMNOP";
36 const char x_abs[]            = "1";
36 const char x_close_line[]     = ">";
36 const char x_line_opening[]   = "<";
36 const char x_rac[]            = "3";
36 const char x_rel[]            = "2";
37                     if ( jj2 >= 0 ) {
37                 bCurHasIsoStereo    =
37             /* implicit isotopic H */
37             /************************
37             /************************
37             szBuf[len_buf++] = delim;
37          !(pr->bSecondNonTautPass) &&
37         AT_NUMB *nTrans_n, *nTrans_s;
37         if ( NUM_COORD == num_zer ) {
37         if ( pr.bSecondNonTautPass ) 
37         inchi_strbuf_reset( strbuf );
37         inchi_strbuf_reset( strbuf );
37         inchi_strbuf_reset( strbuf );
37         inchi_strbuf_reset( strbuf );
37         szGetTag( AuxLbl, pr->nTag,  
37     /* InChI output: polymer layer */
37     /* Structure (Compound) Header */
37     Fill out original input structure
37     pr.bNonTautIsIdenticalToTaut = 1;
37     Print error message (plain text) 
37     return nPathLen? pathAtom : NULL;
37   [c|n]              chiral/nonchiral
37 		 && orig_inp_data->polymer->n > 0 )
37 									   ORIG_STRUCT *pOrigStruct,
37 									   ORIG_STRUCT *pOrigStruct,
37 											INCHI_IOSTREAM *out_file, 
37 											INCHI_IOSTREAM *out_file, 
37 		if ( c==','  || c==';' || c=='\0' )
37 	/* InChI output: connection table */
37 const char x_line_closing[]   = "</";
38                                       
38                                       
38                     pr.num_comp[j] --;
38                     val = mw + val -1;
38                 case BOND_TYPE_ALTERN:
38                 case BOND_TYPE_DOUBLE:
38                 case BOND_TYPE_SINGLE:
38                 case BOND_TYPE_TRIPLE:
38              ************************/
38              ************************/
38             bEmbeddedOutputCalled = 1;
38             if ( last_pos > cur_pos ) 
38             if ( last_pos > cur_pos ) 
38             if ( last_pos > cur_pos ) 
38             pr.bSecondNonTautPass = 1;
38             ret |= OutputINChI1( pCG, 
38             szBuf[ cur_len ++ ] = ';';
38         /*-- inverted sp3 start tag */
38         /* plain text with comments */
38         inchi_strbuf_reset( strbuf ); 
38         inchi_strbuf_reset( strbuf ); 
38         inchi_strbuf_reset( strbuf ); 
38         inchi_strbuf_reset( strbuf ); 
38         inchi_strbuf_reset( strbuf ); 
38         inchi_strbuf_reset( strbuf ); 
38         sets terminating '\0' in pStr,
38     for ( i = 0; i < TAUT_NUM; i ++ ) 
38     if (!pr.num_components ) return 0;
38   [.]{o|e|u|?} atom parity = {1:2:3:4}
38  * Software version 1.05 (pre-release)
38 															 print_INCHI_local *pr,
38 																		 int *compnt_nums );
38 																				out_file, strbuf, 
38 												INCHI_IOSTREAM *out_file, 
38 			inchi_strbuf_printf( strbuf, ";" );
38 	if ( NULL == compnt_nums )		return 1;
38 const char x_type_predec[]    = "sct";
38 int OutputINChI1( CANON_GLOBALS *pCG, 
38 int OutputINChI2( CANON_GLOBALS *pCG, 
39                            int bError )
39                     /* real neighbor */
39                     goto exit_function;
39                     goto exit_function;
39                   int bCtPredecessors, 
39                   int bCtPredecessors, 
39                   int bNoStructLabels, 
39                   int bNoStructLabels, 
39                   int num_input_struct,
39                   int num_input_struct,
39                   int num_non_taut2[], 
39                   int num_non_taut2[], 
39             /* remove leading zeroes */
39             case (iiEq2ISO | iiEq2INV):
39             case (iitNONTAUT | iitISO):
39             if ( val = at[j].charge ) {
39             pr->bSecondNonTautPass = 0;
39             pr->tot_len = pr->tot_len2;
39             pr->tot_len = pr->tot_len2;
39             pr->tot_len = pr->tot_len2;
39             pr->tot_len = pr->tot_len2;
39             pr->tot_len2 = pr->tot_len;
39             pr.bInvStereo[i]         = 
39             pr.iCurTautMode = TAUT_NON;
39         /* Original numbering output */
39         if ( pr->bPlainTextTags == 1 ) 
39         if ( pr->bPlainTextTags == 1 ) 
39         if ( pr->bPlainTextTags == 1 ) 
39         if ( pr->bPlainTextTags == 1 ) 
39         pr.bIsotopicOrigNumb[i]      = 
39         pr.bNonTautIsIdenticalToTaut = 
39     AT_NUMB nNeighOrder[MAXVAL], neigh;
39     IL_MAX_ORD /* max number of tags */
39     Output structure (compound) header 
39     static const char szIsoH[] = "hdt";
39 								 INCHI_IOSTREAM_STRING *strbuf,
39 	if ( NULL == strbuf->pStr )		return 1;
39 const char x_type[]           = "type";
40                                         
40                              INCHI_REC, 
40                         bond_char = 'd';
40                         bond_char = 'n';
40                         bond_char = 'N';
40                         bond_char = 'p';
40                         bond_char = 'P';
40                         bond_char = 's';
40                         bond_char = 'v';
40                         bond_char = 'v';
40                         bond_char = 'V';
40                         bond_char = 'w';
40                         if ( bCurTaut ) 
40                         if ( val > 1 ) {
40                        STRUCT_DATA *sd )
40                     | CT_MODE_NO_ORPHANS
40                 switch ( pr.bOutType ) {
40             (out_file->s.nUsedLength)--;
40             if ( val = at[j].radical ) {
40             len = (int) strlen( szTag );
40             return 1; /* pStr overfow */
40             return 1; /* pStr overfow */
40             szBuf[cur_len += len] = ';';
40         /*-- isotopic aux info header */
40         /*-- Isotopic inverted stereo */
40         /* v. 1.05 for LargeMolecules */
40         if ( buf->pStr[0] || ind < -1 ) 
40         if ( intermediate_result != 0 ) 
40         if ( intermediate_result != 0 ) 
40         if ( intermediate_result != 0 ) 
40         if ( intermediate_result != 0 ) 
40         if ( intermediate_result != 0 ) 
40         if ( intermediate_result != 0 ) 
40         if ( intermediate_result != 0 ) 
40         if ( len + cur_len < buf_len ) {
40         pr->nCurINChISegment   = DIFL_F;
40     /* InChI output: version and kind */
40     called from SortAndPrintINChI( ... )
40     for ( j = *i; j < num_inp_atoms; ) {
40     for ( j = *i; j < num_inp_atoms; ) {
40     for ( j = *i; j < num_inp_atoms; ) {
40     INChI        *pINChI /*, *pINChI2*/;
40     pr.bOutType = bOutputType; /* ??? */
40 		printf("%-d )\n", u->alist[u->na-1] );
40 	memset( units2, 0, sizeof( *units2 ) );
40 const char x_basic_layer[]    = "basic";
40 const char x_text[]           = "value";
40 const char x_type_alpha[]     = "alpha";
40 int WriteOrigAtoms( CANON_GLOBALS *pCG, 
40 int WriteOrigBonds( CANON_GLOBALS *pCG, 
41                                 continue;
41                                 continue;
41                                 continue;
41                                 continue;
41                         if ( p1 && p2 ) {
41                     /* inverted stereo */
41                     | CT_MODE_ATOM_COUNTS
41                     case -STEREO_SNGL_UP:
41                     case  STEREO_SNGL_UP:
41                     strcat( szTag, ":" );
41                   /* <%s: >, x_message */
41                   int num_components2[], 
41                   int num_components2[], 
41                 len = sizeof(szCurCoord);
41              /* detected transposition */
41             AT_NUMB *nTrans_n, *nTrans_s;
41             inchi_strbuf_reset( strbuf );
41         inchi_ios_print( out_file, "%s", 
41     /* - add 'Beta' flag if applicable */
41     AL_MAX_ORD   /* max number of tags */
41     bTautAndNonTaut = bTautIsNonTaut = 0;
41     if ( !bEmbeddedOutputCalled							&& 
41     int  bTautAndNonTaut, bTautIsNonTaut;
41     Output InChI: InChI version and kind 
41     pr.bNonTautIsoIdentifierNotEmpty = 0;
41 																		 print_INCHI_local *pr,
41 											INCHI_IOSTREAM_STRING *strbuf,
41 											INCHI_IOSTREAM_STRING *strbuf,
41 const char x_number[]         = "number";
41 const char x_type_normal[]    = "normal";
42                     /* exponent is zero */
42                     if ( jj == TAUT_YES ) 
42                   const char *szSdfLabel, 
42                   const char *szSdfLabel, 
42                   const char *szSdfValue, 
42                   const char *szSdfValue, 
42                   int bDisconnectedCoord, 
42                   int bDisconnectedCoord, 
42                 if ( cur_pos < last_pos ) 
42                 if ( cur_pos < last_pos ) 
42                 pr.bSecondNonTautPass = 0;
42             inchi_strbuf_reset( strbuf ); 
42             inchi_strbuf_reset( strbuf ); 
42             inchi_strbuf_reset( strbuf ); 
42             inchi_strbuf_reset( strbuf ); 
42             inchi_strbuf_reset( strbuf ); 
42             pr.bInvStereoOrigNumb[i] =  0;
42             pr.bOutType     = OUT_NONTAUT;
42          pr->bNonTautIsIdenticalToTaut && 
42         /* tetrahedral parity treatment */
42         for ( i = 0; i < TAUT_NUM; i ++ ) 
42         inchi_strbuf_printf( strbuf, "B");
42         inchi_strbuf_printf( strbuf, "S");
42         pr->tot_len = strbuf->nUsedLength;
42     *pLF = bPlainTextCommnts? "\n" : "\0";
42     if ( pr->bAtomEqu[pr->iCurTautMode] ) 
42 												INCHI_IOSTREAM_STRING *strbuf,
42 	for (k =0; k <= strbuf->nUsedLength; k++)
42 	inchi_strbuf_printf( strbuf, "%s", "/z");
42 #if ( FIX_EITHER_STEREO_IN_AUX_INFO == 1 )
42 const char x_header[]         = "id.name";
42 const char x_message[]        = "message";
42 const char x_type_numer[]     = "numeric";
42 const char x_ver[]            = "version";
42 const char x_warn[]           = "warning";
43                                    strbuf, 
43                     case -STEREO_SNGL_DOWN:
43                     case  STEREO_SNGL_DOWN:
43                     pinxt2cur = pinxt2cur2;
43                     pnxt_atom = pnxt_atom2;
43                     switch( bond_stereo ) {
43                     switch( bond_stereo ) {
43                   int bINChIOutputOptions, 
43                   int bINChIOutputOptions, 
43                   ORIG_STRUCT *pOrigStruct,
43                   ORIG_STRUCT *pOrigStruct,
43                 /*  close non-tautomeric */
43                 chain_len = chain_len2 = 0;
43                 if ( at[j].sb_parity[0] ) {
43                 pr->tot_len2 = pr->tot_len;
43             (*pr->pSortPrintINChIFlags) |= 
43             (*pr->pSortPrintINChIFlags) |= 
43             (*pr->pSortPrintINChIFlags) |= 
43             /* isotopic #4: abs inverted */
43             bIsotopicStereoAbs[i]         =
43             bIsotopicStereoAbsInverted[i] =
43             case (iiEq2NONTAUT | iiEq2INV):
43             case (iiEq2NONTAUT | iiEq2ISO):
43             goto exit_function; /* error */
43             if ( !(*pSortPrintINChIFlags & 
43             if ( orig_inp_data->szCoord ) {
43             if ( pr->bPlainTextTags == 1 ) 
43             if ( pr->bPlainTextTags == 1 ) 
43             if ( pr->bPlainTextTags == 1 ) 
43             if ( pr->bPlainTextTags == 1 ) 
43             if ( pr->bPlainTextTags == 1 ) 
43             if ( pr->bPlainTextTags == 1 ) 
43             if ( pr->bPlainTextTags == 1 ) 
43             if ( q = strchr(szVal, '.') ) {
43            (a) pStr has non-zero length, or
43         /*-- Tautomeric groups, isotopic */
43         /* isotopic atoms without mobile H.
43         if ( pr.bTautomericOutputAllowed ) 
43         inchi_ios_print( out_file, "%s%s", 
43     First, checks if buffer overflow; then:
43 		printf("\n*** Polymer unit %-d : ( ", i);
43 	/* hydrogen atoms (do not output empty) */
43 	/* hydrogen atoms (do not output empty) */
43 	unum		= inchi_calloc( p->n, sizeof(int) );
43 const char x_inchi[]          = INCHI_NAME;
43 const char x_tautomeric[]     = "mobile-H";
43 const char x_value[]          = "id.value";
43 int FillOutOrigStruct( CANON_GLOBALS *pCG, 
44                     | CT_MODE_EQL_H_TOGETHER
44                     chain_len  = chain_len2;
44                     parity = at[j].p_parity;
44                     pr.bIsotopic	|= bCurIso;
44                   INCHI_IOSTREAM *log_file, 
44                   INCHI_IOSTREAM *log_file, 
44                   INCHI_IOSTREAM *out_file, 
44                   int *pSortPrintINChIFlags,
44                   int *pSortPrintINChIFlags,
44                 /* detected transposition */
44                 dec_pnt = (int) (q - szVal);
44                 if ( at[j2].sb_parity[0] ) {
44                 jj = GET_II(pr.bOutType,is);
44                 jj = GET_II(pr.bOutType,is);
44                 jj = GET_II(pr.bOutType,is);
44                 pr.bIsotopic		   |= bCurIso;
44             *bAlways = Tag[j].bAlwaysOutput;
44             case iitISO: /* main iso = ...*/
44             case iitISO: /* main iso = ...*/
44             pr->bOutType           = OUT_TN;
44         case 0:         /* numb main = ...*/
44         charges, radicals, unusual valences 
44         if ( !orig_inp_data->num_inp_atoms )
44         if ( !orig_inp_data->num_inp_atoms )
44         if ( len + cur_len + 1 < buf_len ) {
44         if ( len + cur_len + 2 < buf_len ) {
44         inchi_ios_print( out_file, "%s%s%s",
44     *pTAB = bPlainTabbedOutput? "\t" : "\n";
44     /* InChI output: FixedH and sublayers */
44     if ( pr->bInvStereo[pr->iCurTautMode] ) 
44     int  bTautomericAcid, bHardAddRemProton;
44     MarkUnusedAndEmptyLayers( pr.sDifSegs );
44     pr.bNonTautNonIsoIdentifierNotEmpty = 0;
44  * International Chemical Identifier (InChI)
44  * IUPAC/InChI-Trust Licence No.1.0 for the 
44 		pOrigStruct->v3000 = orig_inp_data->v3000;
44 	/* Sort all units in lexicographic order */
44 const char x_structure[]      = "structure";
44 int iicomp(PolymerUnit* u1, PolymerUnit* u2)
44 p = up from the current atom to the neighbor
44 P = uP from the neighbor to the current atom
45                                              
45                                      strbuf, 
45                            char *pErrorText, 
45                         if ( p1NM && p2NM ) {
45                     case -STEREO_DBLE_EITHER:
45                     case -STEREO_SNGL_EITHER:
45                     case -STEREO_SNGL_EITHER:
45                     case  STEREO_DBLE_EITHER:
45                     case  STEREO_SNGL_EITHER:
45                     case  STEREO_SNGL_EITHER:
45                     picur_sb_parity_ord = -1;
45                     picur_sb_parity_ord = -1;
45                  INCHI_IOSTREAM_STRING *buf, 
45                 /* -- not used 2004-09-16 ---
45                 ;/* add error message here */
45                 goto repeat_INChI_Aux_output;
45                 if ( (val = abs(val)) > 1 ) {
45                 inchi_strbuf_reset( strbuf );
45                 len = (int) (p - szCurCoord);
45             if ( val = at[j].iso_atw_diff ) {
45             inchi_ios_print( out_file, "/" );
45          i == orig_inp_data->num_inp_atoms ) 
45         binary options (at 26-base encoding).
45         InChI output:  reconnected structure	
45         line_len = nMaxLineLen - pr->tot_len;
45         line_len = nMaxLineLen - pr->tot_len;
45         line_len = nMaxLineLen - pr->tot_len;
45        /h   -  immobile H & mobile H group(s)
45     /* - add 'Standard' flag if applicable */
45     /* InChI output: stereo (non-isotopic) */
45     /* Switch from M to MI or from F to FI */
45     if ( len_buf < (int)sizeof(MOL_COORD) ) {
45     Output InChI: stereo layer with sublayers
45  * International Chemical Identifier (InChI) 
45 		units2[i] = PolymerUnit_copy( p->unit[i] );
45 const char x_basic[]          = "identifier";
45 const char x_type_short[]     = "compressed";
46                                  pOrigStruct, 
46                             bTautIsNonTaut ++;
46                             if ( bHasMetal ) {
46                     if ( !bCurIsoStereoSp3 ) {
46                   unsigned char save_opt_bits)
46                   unsigned char save_opt_bits)
46                  int ind, int bPlainTextTags )
46                 inchi_strbuf_reset( strbuf ); 
46                 inchi_strbuf_reset( strbuf ); 
46                 inchi_strbuf_reset( strbuf ); 
46                 inchi_strbuf_reset( strbuf ); 
46                 inchi_strbuf_reset( strbuf ); 
46                 int n_added = tag_len + 2 + 2;
46                 last_pos = cur_pos + line_len;
46                 orig_inp_data->szCoord = NULL;
46                 switch( at[j].bond_type[k] ) {
46             /* check for removed isotopic H */
46             bCurOption = INCHI_OUT_PLAIN_TEXT;
46             inchi_ios_print( out_file, "//" );
46             pr->iCurTautMode       = TAUT_YES;
46             pr.bInvIsotopicStereo[i]         =
46          i == orig_inp_data->num_inp_atoms ) {
46         /* end of disconnected INChI output */
46         currently encoded by A through D. 
46         if ( MIN_BOND_LENGTH > fabs(coord)  ) 
46         memcpy( szVal, szCoord+k, LEN_COORD );
46         r = "??";      /* should not happen */
46     int  ret = 0; /*  0=>failed, 1=>success */
46  * Copyright (C) IUPAC and InChI Trust Limited
46  * whatsoever, whether expressed or implied.  
46 															 INCHI_IOSTREAM_STRING *strbuf,
46 			if  ( u->blist[ 2*k ] > u->blist[ 2*k+1 ] )
46 			u->alist[k] = cano_nums[ u->alist[k] ] + 1;
46 			u->blist[k] = cano_nums[ u->blist[k] ] + 1;
46 		if ( u1->alist[i] > u2->alist[i] )	return 1;
46 	PolymerDescription *p = pOrigStruct->polymer;
46 const char x_curr_ver[]       = INCHI_VERSION;
46 const char x_reconnected[]    = "reconnected";
46 n = down from the current atom to the neighbor
46 N = dowN from the neighbor to the current atom
47                 -----------------------------*/
47                                 neigh1 = neigh;
47                                 neigh2 = neigh;
47                         char *pLF, char *pTAB )
47                     ; /* invalid atom parity */
47                     chain_len = chain_len2 = 0;
47                   INCHI_IOSTREAM *output_file, 
47                 /* check for allene/cumulene */
47                 /* main path of control flow */
47                 case (iiEq2NONTAUT | iiEq2ISO):
47                 case (iiEq2NONTAUT | iiEq2ISO):
47                 case (iiEq2NONTAUT | iiEq2ISO):
47                 case (iiEq2NONTAUT | iiEq2ISO):
47                 goto exit_function; /* error */
47                 if ( pr->bPlainTextTags == 1 ) 
47                 if ( pr->bPlainTextTags == 1 ) 
47                 if ( pr->bPlainTextTags == 1 ) 
47                 if ( pr->bPlainTextTags == 1 ) 
47                 pr.bOutType           = OUT_TN;
47             else if ( pr.bPlainTextTags == 1 ) 
47             inchi_free( pOrigStruct->szAtoms );
47             inchi_free( pOrigStruct->szBonds );
47             inchi_free( pOrigStruct->szCoord );
47         case 0: /* inv stereo numb main = ...*/
47         inchi_ios_print( out_file, "%s", pLF );
47         memcpy( szCurAtom, at[j].elname, len );
47      /i/h   -  exchangeable isotopic H (common)
47     /* -- commented out to allow empty InChI --
47     Output InChI: isotopic layer and sublayers	
47 				p = is_in_the_ilist( u->alist, b1, u->na );
47 		if ( u1->alist[i] < u2->alist[i] )	return -1;
47 	Compare two polymer units, lexicographic order
47 int Output_AUXINFO_stereo( CANON_GLOBALS *pCG, 
47 void FreeOrigStruct(  ORIG_STRUCT *pOrigStruct)
48                         neigh1  = num_inp_atoms;
48                         neigh2  = num_inp_atoms;
48                      "%s: %s=\"%s\" %s=\"%s\"", 
48                     jj = GET_II(pr.bOutType,is);
48                     jj = GET_II(pr.bOutType,is);
48                     jj = GET_II(pr.bOutType,is);
48                   INCHI_IOSTREAM_STRING *strbuf,
48                 *bAlways = Tag[j].bAlwaysOutput;
48                 if ( bRequestedRelativeStereo ) 
48             if ( length - cur_pos >= line_len ) 
48             if ( length - cur_pos >= line_len ) 
48             if ( length - cur_pos >= line_len ) 
48         /* do not output inverted stereo info */
48         /*if ( bStereoSp2[pr->iCurTautMode]  )*/
48         /*if ( bStereoSp3[pr->iCurTautMode]  )*/
48         case iitISO:  /* iso main stereo =... */
48         if ( bINChIOutputOptions & bCurOption ) 
48         inchi_ios_print( out_file, "%s", pTAB );
48         inchi_ios_print( out_file, "%s", pTAB );
48     if ind < 0 (common usage, plain text output)
48     if ind < 0 (common usage, plain text output)
48     memcpy( szCoord, szBuf, sizeof(MOL_COORD) );
48 		pOrigStruct->polymer = orig_inp_data->polymer;
48 int orig_num, cano_num, icompnt, k, ndigit, err;
49                                    pr->bOutType, 
49                                  &pr,pLF, pTAB );
49                             if ( neigh < neigh1 )
49                             if ( neigh < neigh2 )
49                             if ( p1NM && p2NM ) {
49                        ORIG_STRUCT *pOrigStruct, 
49                   /* <%s=\"%s\">, x_type, pErr */
49                   INCHI_IOSTREAM_STRING *strbuf, 
49                 goto repeat_INChI_Aux_Iso_output;
49                 inchi_ios_print( out_file, "/" );
49                 inchi_ios_print( out_file, "/" );
49                 inchi_ios_print( out_file, "/" );
49                 inchi_ios_print( out_file, "/" );
49                 neigh = at[j].p_orig_at_num[n]-1;
49                 pr.iCurTautMode       = TAUT_YES;
49             case iitNONTAUT: /* non-taut = ... */
49             case iitNONTAUT: /* non-taut = ... */
49             pr.bInvIsotopicStereoOrigNumb[i] = 0;
49          pOrigStruct && pOrigStruct->num_atoms &&
49         /*-- inverted sp3  canonical numbering */
49         /* avoid leading slash in plain output */
49         /*	Charges, radicals, unusual valences */
49         case iitISO:     /* iso numb main = ...*/
49         for ( j = TAUT_NON; j < TAUT_NUM; j ++ ) 
49       then we need to output non-tautomeric data:
49     int  i, len, len_coord, len_atoms, len_bonds;
49     Output AuxInfo: header and normalization type
49   .#rad  (#rad=1, 2, 3: singlet, doulet, triplet)
49 													  &INCHI_basic_or_INCHI_reconnected,
49 																		 INCHI_IOSTREAM_STRING *strbuf,
49 											int *INCHI_basic_or_INCHI_reconnected,
49 											int *INCHI_basic_or_INCHI_reconnected,
49 	inchi_strbuf_reset( strbuf );	/* clear buffer */
49 	inchi_strbuf_reset( strbuf );	/* clear buffer */
49 const char x_ign_uu_sp3[]     = "omit_undef_sp3";
50                                    pr->TAUT_MODE, 
50                             if ( kc == picur2nxt )
50                             if ( kc == pinxt2cur )
50                            char *pLF, char *pTAB )
50                            print_INCHI_local *pr, 
50                     /* inverted isotopic stereo */
50                     if ( bWellDef || bHasMetal ) {
50                 bHasIsotopicAtoms[ii]  |= bCurIso;
50                 inchi_ios_print( out_file, "//" );
50                 last_pos = cur_pos + line_len - 1;
50                 last_pos = cur_pos + line_len - 1;
50                 memcpy( buf->pStr, tag, tag_len );
50              i == orig_inp_data->num_inp_atoms ) {
50             r = "??";      /* should not happen */
50             r = "??";      /* should not happen */
50         /* if ( bStereoAbs[pr->iCurTautMode]  ) */
50         case iitNONTAUT: /* numb non-taut = ... */
50         if ( INCHI_SEGM_FILL == pr->nSegmAction ) 
50         if ( INCHI_SEGM_FILL == pr->nSegmAction ) 
50         if ( INCHI_SEGM_FILL == pr->nSegmAction ) 
50         len = len0 = (int) strlen( at[j].elname );
50     int bType = EquVal & (iitISO   | iitNONTAUT );
50     Output AuxInfo: tautomeric groups equivalence 
50 									   int *INCHI_basic_or_INCHI_reconnected,
50 									   int *INCHI_basic_or_INCHI_reconnected,
50 												int *INCHI_basic_or_INCHI_reconnected,
50 								/* pointer copy, do not free after use! */
50 								/* pointer copy, do not free after use! */
50 							char *szBuf, int buf_len, STRUCT_DATA *sd);
50 	/* Make a working copy of polymeric units data */
50 	if ( NULL != cano_nums )	inchi_free( cano_nums );
50 const char x_ferr[]           = "fatal (aborted)";
50 int CleanOrigCoord( MOL_COORD szCoord, int delim )
50 int str_LineEnd( const char *tag, int *bOverflow, 
51                                    &pr->bOverflow, 
51                              print_INCHI_local *pr,
51                             i < pr.num_components; 
51                         pr.bChargesRadVal[ii] |= 1;
51                     if ( bRequestedRacemicStereo ) 
51                 bond_stereo = at[j].bond_stereo[k];
51                 if ( jj == j && pINChI->bDeleted ) 
51             /*-- inverted isotopic sp3 start tag */
51             inchi_ios_print( out_file, "%s", pLF );
51             inchi_ios_print( out_file, "%s", pLF );
51             inchi_ios_print( out_file, "%s", pLF );
51             inchi_ios_print( out_file, "%s", pLF );
51             pCG->m_pn_RankForSort = at[j].neighbor;
51         /* bStereoAbsInverted[pr->iCurTautMode]  */
51         case 0:         /* equivalence main = ...*/
51         case iitNONTAUT: /* non-taut stereo =... */
51         for ( kk = 0; kk < at[j].valence; kk ++ ) {
51     (used to check for repeating (sub)layer(s) )			
51     /* InChI output: charge and  removed protons */
51     Called from OutputINChI2( ... ) and from itself
51     if ( num_components2[0] || num_components2[1] )
51     inchi_strbuf_printf( strbuf, "%s", x_curr_ver);
51     int  pcur_atom, picur2nxt, picur_sb_parity_ord;
51     pr.pSortPrintINChIFlags = pSortPrintINChIFlags;
51 const char x_err[]            = "error (no InChI)";
51 const char x_ign_uu_sp2[]     = "omit_undef_dbond";
51 int Output_INCHI_stereo_layer( CANON_GLOBALS *pCG, 
52                                    pr->pINChISort2, 
52                                 int bNoStructLabels,
52                              (is->pINChI[TAUT_YES]);
52                              char *pLF, char *pTAB )
52                             picur_sb_parity_ord = m;
52                             picur_sb_parity_ord = m;
52                     /* central atom is a neighbor */
52                     /* new exp; update the length */
52                 /*pINChI_Aux = is->pINChI_Aux[jj];*/
52                 bCurRacemic         = bCurRacemic &&
52                 inchi_strbuf_update( buf, n_added );
52                 szCurAtom[len++] = val>0? '+' : '-';
52             for ( j = 0; j < NUM_H_ISOTOPES; j ++ ) 
52             for ( k = 0; k < at[j].valence; k ++ ) {
52          TAUT_BOTH => tautomeric and non-tautomeric 
52         /* add the second (non-tautomeric) output */
52         /* AuxInfo: tautomeric groups equivalence */
52         num_zer = CleanOrigCoord( szCurCoord, ',' );
52     { /* plain text comment earlier ended with LF */
52     if ( num_components2[0] || num_components2[1] ) 
52     if ( num_components2[0] || num_components2[1] ) 
52     int  bStereoSp2[TAUT_NUM], bStereoSp3[TAUT_NUM];
52     memset( pr.num_iso_H, 0, sizeof(pr.num_iso_H) );
52     nEstLen =     (int) (sizeof(x_message)-1 + 1 + 1
52 #define SP(N)        (x_space+sizeof(x_space)-1-(N))
52 static int iicomp(PolymerUnit* u1, PolymerUnit* u2);
53                                   strbuf->pStr, pLF);
53                            INCHI_IOSTREAM *out_file, 
53                     if ( val = at[j].num_iso_H[k] ) {
53                     inchi_ios_print( out_file, "/" );
53                     inchi_ios_print( out_file, "/" );
53                 i --; /* remove decimal point, too */
53                 inchi_free( orig_inp_data->szCoord );
53                 memmove( szTag + num, szTag, len+1 );
53             for ( j = TAUT_NON; j < TAUT_NUM; j ++ ) 
53             for ( j = TAUT_YES; j < TAUT_NUM; j ++ ) 
53             if ( INCHI_SEGM_FILL == pr->nSegmAction )
53         /* AuxInfo: header and normalization type */	
53         /*if ( bIsotopicStereo[pr->iCurTautMode] )*/ 
53         int bCompExists, bCurIsoHPos, bCurIsoHStereo;
53         pr.bTautomeric += (bHardAddRemProton? 4 : 0);
53         Symmetry numbers (constit. equivalence)	/E:		
53     Output InChI: charge and  removed protons layers 
53     Output InChI: FixedH layer and related sublayers	
53     pr.num_components = pr.num_comp[pr.iCurTautMode];
53 		/*memset( pOrigStruct, 0, sizeof(*pOrigStruct) );*/
53 	/* InChI output: hydrogens (with tautomeric info) */
53 	units2 = inchi_calloc( p->n, sizeof(PolymerUnit*) );
53 #ifdef OLD_ITEM_DISCOVERY                            
53 const char x_space[]          = "                  ";
53 int Output_INCHI_isotopic_layer( CANON_GLOBALS *pCG, 
53 int OutputINChIPlainError( INCHI_IOSTREAM *out_file, 
54                                     int nAtomsAllComp,
54                                    pr->num_components,
54                         if ( k == at[j].sb_ord[m1] ) {
54                        ORIG_ATOM_DATA *orig_inp_data, 
54                 bCurIsoRacemic      = bCurIsoRacemic &
54                 bCurRelative        =  bCurRelative &&
54                 r = "??";      /* should not happen */
54                 r = "??";      /* should not happen */
54                 r = "??";      /* should not happen */
54                 r = "??";      /* should not happen */
54                 r = "??";      /* should not happen */
54                 r = "??";      /* should not happen */
54                 r = "??";      /* should not happen */
54                 r = "??";      /* should not happen */
54                 strcpy ( szTag, Tag[j].szPlainLabel );
54             if ( !pr->bNonTautIsoIdentifierNotEmpty ) 
54             if ( INCHI_SEGM_FILL == pr->nSegmAction ) 
54             if ( INCHI_SEGM_FILL == pr->nSegmAction ) 
54             memcpy( szBuf + cur_len, szCurAtom, len );
54             num = (int) strlen( Tag[j].szPlainLabel );
54             r = "??";          /* should not happen */
54         /*if ( !pr->bSecondNonTautPass && bHasIsoH )*/
54         if ( pr->bIsotopicAtomEqu[pr->iCurTautMode] ) 
54         inchi_strbuf_reset( strbuf ); pr->tot_len = 0;
54         inchi_strbuf_reset( strbuf ); pr->tot_len = 0;
54         inchi_strbuf_reset( strbuf ); pr->tot_len = 0;
54         inchi_strbuf_reset( strbuf ); pr->tot_len = 0;
54         inchi_strbuf_reset( strbuf ); pr->tot_len = 0;
54         inchi_strbuf_reset( strbuf ); pr->tot_len = 0;
54     *let1 = a2p [ (size_t) ( save_opt_bits & 0x0f ) ];
54   Parsing plain text InChI (FML is a chemical formula)
54 			inchi_strbuf_printf( strbuf, "%-d,", u->alist[k] );
54 	if ( NULL != compnt_nums )	inchi_free( compnt_nums );
54 int Output_AUXINFO_isotopic_info( CANON_GLOBALS *pCG, 
54 static int Output_AUXINFO_stereo( CANON_GLOBALS *pCG, 
55                                    pr->bUseMulipliers);
55                             sd->nErrorType = _IS_ERROR;
55                             sd->nErrorType = _IS_ERROR;
55                             sd->nStructReadError =  99;
55                             sd->nStructReadError =  99;
55                         if ( neigh1 < num_inp_atoms ) {
55                         if ( neigh2 < num_inp_atoms ) {
55                         pr.bInvStereo[ii]         |= 1;
55                     pr.bNonTautomeric     |= HAS_N(is);
55                   int INCHI_basic_or_INCHI_reconnected,
55                   int INCHI_basic_or_INCHI_reconnected,
55                 buf->nUsedLength = strlen( buf->pStr );
55                 nAtomsAllComp+= pINChI->nNumberOfAtoms;
55                 pr->tot_len = str_Sp2( pr->pINChISort, 
55                 strcat( szTag, Tag[i].szPlainComment );
55             bCurOption = INCHI_OUT_PLAIN_TEXT_COMMENTS;
55             if ( INCHI_SEGM_FILL == pr->nSegmAction ) {
55             if ( INCHI_SEGM_FILL == pr->nSegmAction ) {
55             memcpy( szBuf + cur_len, szCurBonds, len );
55             r = "??";           /* should not happen */
55             r = "??";           /* should not happen */
55             r = "??";           /* should not happen */
55         GetSaveOptLetters(save_opt_bits, &let1, &let2);
55         if ( pr->bIsotopicOrigNumb[pr->iCurTautMode] ) 
55         inchi_strbuf_printf( strbuf, "%s", x_curr_ver);
55 neighbor orig. atom number < number of the current atom
56                                                   j2+1);
56                                  print_INCHI_local *pr, 
56                                 char *pLF, char *pTAB );
56                                 strbuf, &pr->bOverflow, 
56                         if ( k2 == at[j2].sb_ord[m2] ) {
56                    INCHI_IOSTREAM_STRING *buf, int ind )
56                 bCurIsoRelative     = bCurIsoRelative &&
56                 bStereoSp2[ii]         |= bCurStereoSp2;
56                 bStereoSp3[ii]         |= bCurStereoSp3;
56                 strbuf->pStr[last_pos - cur_pos] = '\0';
56                 strbuf->pStr[last_pos - cur_pos] = '\0';
56             /* add the second (non-tautomeric) output */
56             inchi_ios_print( out_file, ":%ld", lSdfId );
56           Currently, this is enabled for xml output only
56         case iitISO:     /* equivalence main iso = ...*/
56         case iitISO: /* inv stereo iso numb main = ...*/
56         cur_len = sprintf( szBuf, "%d%s", num_inp_atoms,
56         if ( pr->bInvIsotopicStereo[pr->iCurTautMode] ) 
56         if ( pr->bInvStereoOrigNumb[pr->iCurTautMode] ) 
56         inchi_ios_print( out_file, "%s", strbuf->pStr );
56         optionally adds leading tag (e.g., '/' or "/c" )
56         pr->tot_len = str_AuxTgroupEqu( pr->pINChISort, 
56     else if ( bINChIOutputOptions & INCHI_OUT_STDINCHI )
56     if ( !bEmbeddedOutputCalled && !bPlainTextCommnts ) 
56     if ( *INCHI_basic_or_INCHI_reconnected==INCHI_BAS ) 
56     Main actual worker which serializes InChI to string.
56 	inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
57                                    pr->bOmitRepetitions, 
57                                   char *pLF, char *pTAB )
57                                   print_INCHI_local *pr, 
57                                   print_INCHI_local *pr, 
57                             bond_parity = AB_PARITY_UNDF;
57                            INCHI_IOSTREAM_STRING *strbuf,
57                         inchi_ios_print( out_file, "/" );
57                 for ( k = 0; k < NUM_H_ISOTOPES; k ++ ) {
57                 if ( bCurStereoSp2 && bCurIsoStereoSp2 ) 
57                 if ( bCurStereoSp3 && bCurIsoStereoSp3 ) 
57                 memmove( szVal + fst, szVal+i, len-fst );
57                 strbuf->nUsedLength = last_pos - cur_pos;
57                 strbuf->nUsedLength = last_pos - cur_pos;
57             if ( !pr->bNonTautNonIsoIdentifierNotEmpty ) 
57             last -= 1; /* last mantissa digit position */
57         case iitNONTAUT: /* equivalence non-taut = ... */
57         pr.num_components = pr.num_comp[pr.iCurTautMode];
57         reversibility info (to restore orig. structure)  
57     if ( bINChIOutputOptions & INCHI_OUT_ONLY_AUX_INFO ) 
57     if ( INCHI_basic_or_INCHI_reconnected == INCHI_BAS ) 
57     if ( nAtomsAllComp > NORMALLY_ALLOWED_INP_MAX_ATOMS )
57  * 'External-contributors' included in this distribution.
57 			             INCHI_IOSTREAM_STRING *strbuf, int ind );
57 int Output_INCHI_main_layer_formula(	CANON_GLOBALS *pCG, 
57 int str_LineStart( const char *tag,char *tag2, int val2, 
57 static int str_LineEnd( const char *tag, int *bOverflow, 
58                                   char *pLF, char *pTAB );
58                     bNeighSwitched1 = bNeighSwitched2 = 0;
58                 if ( INCHI_SEGM_FILL == pr->nSegmAction ) 
58                 if ( INCHI_SEGM_FILL == pr->nSegmAction ) 
58                 if ( INCHI_SEGM_FILL == pr->nSegmAction ) 
58                 if ( INCHI_SEGM_FILL == pr->nSegmAction ) 
58                 memcpy( szTag, Tag[j].szPlainLabel, num );
58             /*-- Isotopic tautomeric groups equivalence */
58             /* Check whether the Fixed-H layer is empty */
58             /* Fixed-H layer is empty in the Identifier */
58             /* plain text comment earlier ended with LF */
58             /*if ( bHasIsotopicAtoms[pr->iCurTautMode] )*/
58             inchi_strbuf_reset( strbuf ); pr->tot_len = 0;
58             inchi_strbuf_reset( strbuf ); pr->tot_len = 0;
58             inchi_strbuf_reset( strbuf ); pr->tot_len = 0;
58             inchi_strbuf_reset( strbuf ); pr->tot_len = 0;
58             inchi_strbuf_reset( strbuf ); pr->tot_len = 0;
58             inchi_strbuf_reset( strbuf ); pr->tot_len = 0;
58             inchi_strbuf_reset( strbuf ); pr->tot_len = 0;
58             Output INChI_Aux of the reconnected structure 
58          OUT_N1: x[TAUT_NON] refers to non-tautomeric only
58         /* no plain text comments: pick up the last tag */
58         inchi_ios_print( out_file, "\\%c%c", let1, let2 );
58     pOrigStruct->num_atoms = orig_inp_data->num_inp_atoms;
58     pr.ATOM_MODE = ((pr.bAbcNumbers?CT_MODE_ABC_NUMBERS:0)
58     pr.pINChISort = pr.pINChISortTautAndNonTaut[TAUT_YES];
58     pr.pINChISort2= pr.pINChISortTautAndNonTaut[TAUT_YES];
58     pr.TAUT_MODE = (pr.bAbcNumbers?CT_MODE_ABC_NUMBERS:0);
58 		inchi_strbuf_printf( strbuf, "%-d", u->alist[u->na-1] );
58 #define OUT_N1              0    /* non-tautomeric only */
58 #if ( FIX_TRANSPOSITION_CHARGE_BUG == 1 ) /* 2008-01-02 */
58 int Output_AUXINFO_reversibility_info( CANON_GLOBALS *pCG,
58 static int CleanOrigCoord( MOL_COORD szCoord, int delim );
58 static int Output_INCHI_stereo_layer( CANON_GLOBALS *pCG, 
59                                     char *pLF, char *pTAB )
59                                    pr->bSecondNonTautPass, 
59                                    strbuf, &pr->bOverflow, 
59                                    strbuf, &pr->bOverflow, 
59                                  INCHI_IOSTREAM *out_file, 
59                         pr.bNonTautomeric     |= HAS_N(is);
59                   /* < %s=\"%s\"\n>, x_text, szErrorText */
59                 bIsotopicStereoSp2[ii] |= bCurIsoStereoSp2;
59                 bIsotopicStereoSp3[ii] |= bCurIsoStereoSp3;
59                 r = "??";           /* should not happen */
59                 r = "??";           /* should not happen */
59                 r = "??";           /* should not happen */
59                 r = "??";           /* should not happen */
59                 r = "??";           /* should not happen */
59                 r = "??";           /* should not happen */
59           (same as above excluding tautomeric information).
59         bonds_val = nBondsValenceInpAt( at+j, NULL, NULL );
59     /*--	Inverted stereo -- sp3 only + canonical numbering 
59     for ( k = 0; k < NUM_COORD*LEN_COORD; k += LEN_COORD ) 
59     inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
59     int len, last, fst, dec_pnt, num_zer=0, len_buf = 0, e;
59     Set line separators dependent on requested output mode 
59 				/* just sort bond ends by increased canonical number */
59 int Output_INCHI_main_layer_hydrogens(	CANON_GLOBALS *pCG, 
59 static int Output_INCHI_polymer_layer( CANON_GLOBALS *pCG, 
59 static int Output_INCHI_polymer_layer( CANON_GLOBALS *pCG, 
60                                                   bond_char,
60                                       print_INCHI_local *pr,
60                                     int bINChIOutputOptions,
60                                   INCHI_IOSTREAM *out_file, 
60                                   INCHI_IOSTREAM *out_file, 
60                         const char *szSdfValue, long lSdfId,
60                         if ( at[pcur_atom].sb_ord[m] == k2 )
60                     /* both atoms belong to a stereo bond */
60                 len += sprintf(szCurAtom + len, ".%d", val);
60                 r = "??";           /* should not happen  */
60             /* dec_pnt = (decimal point position) or last */
60             /* last = (last mantissa digit position + 1)  */
60             /* print the transposition, cycle after cycle */
60             /*if ( bIsotopicStereoSp2[pr->iCurTautMode]  )*/
60             /*if ( bIsotopicStereoSp3[pr->iCurTautMode]  )*/
60             inchi_ios_print( out_file, "%s", strbuf->pStr );
60         /*-- Tautomeric groups constitutional equivalence */
60         /***************************************************
60         if ( !bEmbeddedOutputCalled && !bPlainTextCommnts ) 
60     int  bStereoAbs[TAUT_NUM], bIsotopicStereoAbs[TAUT_NUM];
60     set_line_separators( bINChIOutputOptions, &pLF, &pTAB );
60  * Modifications and additions by IUPAC and the InChI Trust.
60 const char x_aux_basic[]      = "identifier.auxiliary-info";
60 int Output_INCHI_main_layer_connections(CANON_GLOBALS *pCG, 
61                                          pr->bUseMulipliers);
61                                 pr->ATOM_MODE, pr->TAUT_MODE,
61                                 pr->ATOM_MODE, pr->TAUT_MODE,
61                              szSdfLabel, szSdfValue, lSdfId, 
61                         if ( at[pcur_atom].sb_ord[m] == k ) {
61                     if ( bTautAndNonTaut && bTautIsNonTaut &&
61                     int     bNeighSwitched1, bNeighSwitched2;
61                     int num_inp_atoms, inp_ATOM *at, int *i, 
61                     int num_inp_atoms, inp_ATOM *at, int *i, 
61                 inchi_strbuf_reset( strbuf ); pr.tot_len = 0;
61                 len += sprintf( szCurBonds + len, "%c%s%s%d",
61                 memmove( szVal+i+1, szVal+last+1, len-last );
61             for ( i = fst; i < len && '0' == szVal[i]; i ++ )
61             pr.num_components = pr.num_comp[pr.iCurTautMode];
61          * Fixed 2004-06-15: always output if not bXml. Note:
61          ***************************************************/
61         case iitNONTAUT: /* inv stereo numb non-taut = ... */
61         if ( is && (pINChI_Aux = is->pINChI_Aux[TAUT_YES]) ) 
61         int length, cur_pos, line_len, last_pos, nMaxLineLen;
61         which are encoded by capital letters A through P.
61     *let2 = a2p [ (size_t) ( (save_opt_bits & 0x30) >> 4 ) ];
61     /* Original atom numbers in order of canonical numbers */
61     int  i, j, ii, jj, /*ii2, jj2,*/ bEmbeddedOutputCalled=0;
61 int Output_INCHI_version_and_kind(	INCHI_IOSTREAM *out_file, 
61 static int Output_AUXINFO_isotopic_info( CANON_GLOBALS *pCG, 
61 static int Output_AUXINFO_transposition( CANON_GLOBALS *pCG, 
61 static int Output_INCHI_isotopic_layer(  CANON_GLOBALS *pCG, 
62                                             int nAtomsAllComp,
62                                           pr->bUseMulipliers);
62                                         print_INCHI_local *pr,
62                                         print_INCHI_local *pr,
62                                         print_INCHI_local *pr,
62                                        char *pLF, char *pTAB )
62                                        char *pLF, char *pTAB )
62                                        print_INCHI_local *pr, 
62                                       char *pLF, char *pTAB );
62                             bond_parity = inchi_min( p1, p2 );
62                         if ( bond_parityNM && !bond_parity ) {
62                     char *szBuf, int buf_len, STRUCT_DATA *sd)
62                     char *szBuf, int buf_len, STRUCT_DATA *sd)
62                 /* Fixed-H layer is empty in the Identifier */
62                 /* Fixed-H layer is empty in the Identifier */
62                 if ( ATOM_PARITY_ILL_DEF( at[j].p_parity ) ) {
62                 inchi_strbuf_reset( strbuf ); pr->tot_len = 0;
62                 r = "m";       /* numb non-taut = main numb */
62             /*-- inverted isotopic sp3  canonical numbering */
62           then we need to output non-tautomeric auxilialy data
62          * did not optput /i in case of only mobile isotopic H
62         /* Output the original input structure -- quick fix */
62         if ( *INCHI_basic_or_INCHI_reconnected == INCHI_REC ) 
62         The first one encodes RecMet/FixedH/SUU/SLUUD options.
62     for ( i = 0, is2 = pr.pINChISortTautAndNonTaut[TAUT_NON]; 
62     if( (bINChIOutputOptions & INCHI_OUT_NO_AUX_INFO) == 0 )  
62     int  chain_len, pnxt_atom, pinxt2cur, pinxt_sb_parity_ord;
62  * Licence No. 1.0 with this library; if not, please write to:
62 #define ORIG_STR_BUFLEN (7*MAXVAL+2)  /* > 7*MAXVAL+2 = 142 */
62 #define OUT_NONTAUT  OUT_NN  /* was OUT_NT until 2004-04-07 */
62 const char sCompDelim[]       = ";"; /* component delimiter */
62 const char sIdenticalValues[] = "*"; /* identical component */
63                                                     char *pLF, 
63                                          print_INCHI_local *pr,
63                                         char *pLF, char *pTAB )
63                                         char *pLF, char *pTAB )
63                                         char *pLF, char *pTAB )
63                                         int num_components2[], 
63                                         int num_components2[], 
63                                         int num_components2[], 
63                                        char *pLF, char *pTAB );
63                             neigh = at[pcur_atom].neighbor[kc];
63                             neigh = at[pnxt_atom].neighbor[kc];
63                         if ( is->pINChI[jj]->lenTautomer > 0 ) 
63                         pr.bInvIsotopicStereo[ii]         |= 1;
63                        pr->bInvIsotopicStereo[pr->iCurTautMode]
63                     nNeighOrder[k ++] = at[j].p_orig_at_num[n];
63                     pcur_atom = j;  /* pcur_atom > pnxt_atom */
63                     pinxt_sb_parity_ord = pinxt_sb_parity_ord2;
63                     r = "??";           /* should not happen */
63                     r = "??";           /* should not happen */
63                     r = "??";           /* should not happen */
63                     r = "??";           /* should not happen */
63                     r = "??";           /* should not happen */
63                     r = "??";           /* should not happen */
63                     r = "??";           /* should not happen */
63                   + sizeof(x_type)-1 + 1 + 1 + strlen(pErr) + 1
63                 if ( ATOM_PARITY_WELL_DEF( at[j].p_parity ) ) {
63                 r = "m";       /* iso numb main = main numb  */
63             case (iitNONTAUT | iitISO): /* non-taut iso = ...*/
63             case OUT_N1: /* x[TAUT_NON]: non-tautomeric only */
63             pr->tot_len = str_AuxIsoTgroupEqu( pr->pINChISort, 
63         /* Inverted stereo -- sp3 only + canonical numbering */
63         if ( pr->bTautomericOutputAllowed && pr->bTautomeric ) 
63         inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
63         inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
63         inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
63         inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
63         inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
63         inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
63         inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
63         inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
63         inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
63         inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
63         inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
63         just resets buffer pStr (by placing '\0' into pStr[0] )
63         memcpy( szCurCoord, szMolCoord[j], sizeof(szCurCoord));
63         memset( szBuf+len_buf, 0, sizeof(MOL_COORD) - len_buf);
63       At this point the INChI part of the output has been done.
63     if ( bRequestedRacemicStereo || bRequestedRelativeStereo ) 
63     int  bTautIsoHNum, bTautIsoAt, bHasIsotopicAtoms[TAUT_NUM];
63     int bEq2  = EquVal & (iiEq2NONTAUT | iiEq2ISO | iiEq2INV );
64                                          print_INCHI_local *pr, 
64                                          print_INCHI_local *pr, 
64                                         strbuf, &pr->bOverflow, 
64                                         strbuf, &pr->bOverflow, 
64                                        ORIG_STRUCT *pOrigStruct,
64                                       INCHI_IOSTREAM *out_file, 
64                                   INCHI_IOSTREAM_STRING *strbuf,
64                                   INCHI_IOSTREAM_STRING *strbuf,
64                                 parity == AB_PARITY_EVEN?  "e" :
64                                 parity == AB_PARITY_ODD?   "o" :
64                                 parity == AB_PARITY_UNKN?  "u" :
64                        pr->bIsotopicAtomEqu[pr->iCurTautMode] ||
64                     | (bCtPredecessors?CT_MODE_PREDECESSORS:0));
64                 /* print the transposition, cycle after cycle */
64                 bCurTaut            = (pINChI->lenTautomer > 0);
64                 inchi_ios_print( out_file, "%s", strbuf->pStr );
64                 inchi_ios_print( out_file, "%s", strbuf->pStr );
64             fst = (szVal[0]!='.' && !isdigit( UCINT szVal[0] ));
64     /* else *obsolete* XML output, obsolete: NOT USED ANYMORE */
64     /* InChI output: save InChI creation options if requested */
64     case iiSTEREO_INV: /*---------- Inverted Aux Stereo ------*/
64     memset( pr.sDifSegs, DIFV_BOTH_EMPTY, sizeof(pr.sDifSegs) );
64 									pr->ATOM_MODE, pr->num_components, pr->bUseMulipliers);
64 									pr->ATOM_MODE, pr->num_components, pr->bUseMulipliers);
64 	if ( pr->iCurTautMode == TAUT_YES && !pr->bSecondNonTautPass ) 
64 static int Output_INCHI_main_layer_formula(	CANON_GLOBALS *pCG, 
65                                                     char *pTAB );
65                                          char *pLF, char *pTAB );
65                                          char *pLF, char *pTAB );
65                                          char *pLF, char *pTAB );
65                                         0 < num_comp[TAUT_NON]*/ 
65                                        INCHI_IOSTREAM *out_file, 
65                                        INCHI_IOSTREAM *out_file, 
65                                        INCHI_IOSTREAM *out_file, 
65                                  szSdfLabel, szSdfValue, lSdfId, 
65                                  szSdfLabel, szSdfValue, lSdfId, 
65                       (pr->bIsotopicOrigNumb[pr->iCurTautMode] ||
65                     len += sprintf( szCurAtom + len, "%d", val );
65                 r = "m";       /* equivalence main = main equ  */
65             inchi_ios_print( out_file, "%s%s", pr->szTag1, pLF );
65          x = bStereo, bStereoSp2, bStereoSp3, bStereoAbsInverted,
65         /*-- totally omitted undefined/unknown isotopic stereo */
65         case (iitNONTAUT | iitISO): /* numb non-taut iso = ... */
65     case iiSTEREO:  /* ------------ Stereo --------------------*/
65     inchi_ios_print( out_file, "%s%s=%s", pLF, INCHI_NAME, pLF );
65     int  bRequestedRacemicStereo=0, bRequestedRelativeStereo = 0;
65  * (either contractor or volunteer) which are listed in the file 
65 const char x_inchi_ver[]      = "version"; /* "InChI.version"; */
65 int Output_INCHI_FixedH_layer_and_sublayers( CANON_GLOBALS *pCG, 
65 static int Output_AUXINFO_reversibility_info( CANON_GLOBALS *pCG,
65 static int str_LineStart( const char *tag, char *tag2, int val2, 
66                                     INCHI_IOSTREAM_STRING *strbuf,
66                                  INCHI_basic_or_INCHI_reconnected,
66                                 bond_parity = inchi_min( p1, p2 );
66                              out_file, log_file, num_input_struct,
66                              pSortPrintINChIFlags, save_opt_bits);
66                     parity = 2 - (num_trans + at[j].p_parity) % 2;
66                     r = "im";       /* main         = Inv(main) */
66                     r = "im";       /* main iso     = Inv(main) */
66                     r = "im";       /* non-taut     = Inv(main) */
66                     r = "im";       /* non-taut iso = Inv(main) */
66                 pr.bRacemicStereo[ii]              |= bCurRacemic;
66                 r = "m";       /* numb non-taut iso = main numb */
66             tag_len = bPlainTextTags ? (int) strlen( tag ) : 0;			
66         } else {  /* Inv stereo = another (non-inverted) stereo */
66         bIsotopicStereoSp2[i]     = bIsotopicStereoSp3[i]        =
66         bStereoSp2[i]             = bStereoSp3[i]                =
66         for ( cur_pos = 0; cur_pos < length; cur_pos = last_pos ) 
66         for ( cur_pos = 0; cur_pos < length; cur_pos = last_pos ) 
66         for ( cur_pos = 0; cur_pos < length; cur_pos = last_pos ) 
66     int nAtomsAllComp;	/* v. 1.05 Total atoms in all components */
66  * under the terms of the IUPAC/InChI Trust InChI Licence No.1.0, 
66  * You should have received a copy of the IUPAC/InChI Trust InChI 
66 	/* current version does not output empty (";;;;") connectivity */
66 	/* current version does not output empty (";;;;") connectivity */
66 	/* ORIG_STRUCT *pOrigStruct contains pointer to polymeric data */
66 int *is_in_the_ilist( int *pathAtom, int nNextAtom, int nPathLen )
66 static int Output_INCHI_main_layer_hydrogens(	CANON_GLOBALS *pCG, 
67                                                 pr->num_components,
67                                              char *pLF, char *pTAB,
67                                              print_INCHI_local *pr,
67                                            strbuf, &pr->bOverflow, 
67                                          INCHI_IOSTREAM *out_file, 
67                                          INCHI_IOSTREAM *out_file, 
67                                  &INCHI_basic_or_INCHI_reconnected,
67                     inchi_ios_print( out_file, "/" ); /* iso-sp3 */
67                 mw = get_atomic_mass_from_elnum( at[j].el_number );
67                 pr.bRelativeStereo[ii]             |= bCurRelative;
67                 while ( cur_pos < last_pos && p[last_pos] != ';' ) 
67                 while ( cur_pos < last_pos && p[last_pos] != ';' ) 
67             for ( i = last; dec_pnt < i &&  '0' == szVal[i]; i -- )
67             if ( pr->bTautomericOutputAllowed && pr->bTautomeric ) 
67             inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
67             inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
67             inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
67             inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
67             inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
67             inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
67             inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
67             inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
67             inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
67             inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
67             inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
67             inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
67             inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
67             inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
67             inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
67             num_input_struct, SDF_LBL_VAL(szSdfLabel, szSdfValue));
67         bStereoAbs[i]             = bIsotopicStereoAbs[i]         =
67         bStereoAbsInverted[i]     = bIsotopicStereoAbsInverted[i] =
67         case (iitNONTAUT | iitISO): /* iso non-taut stereo = ... */
67         pr->pINChISort    = pr->pINChISortTautAndNonTaut[TAUT_NON];
67         pr->tot_len = str_AuxChargeRadVal( pr->pINChISort, strbuf, 
67         pr->tot_len = str_AuxEqu( pr->pINChISort, pr->pINChISort2, 
67         while ( len = WriteOrigCoord( orig_inp_data->num_inp_atoms,
67       If this INChI is tautomeric and non-tautomeric results exist,
67  * See the IUPAC/InChI-Trust InChI Licence No.1.0 for more details.
67 	pr->tot_len = str_AuxNumb(  pCG, pr->pINChISort, pr->pINChISort2, 
67 	pr->tot_len = str_AuxNumb(  pCG, pr->pINChISort, pr->pINChISort2, 
67 static int Output_INCHI_main_layer_connections(CANON_GLOBALS *pCG, 
68                                              int *then_goto_repeat )
68                                             char *pLF, char *pTAB );
68                                             int bINChIOutputOptions,
68                                       INCHI_IOSTREAM_STRING *strbuf,
68                             bond_parityNM = inchi_min( p1NM, p2NM );
68                      x_message, x_type, pErr, x_text, szErrorText );
68                 bINChIOutputOptionsCur  &= ~INCHI_OUT_TABBED_OUTPUT;
68                 r = "m";       /* equivalence non-taut = main equ */
68             if ( pr->bInvIsotopicStereoOrigNumb[pr->iCurTautMode] ) 
68             pr->num_components     = pr->num_comp[pr->iCurTautMode];
68             pr.nNumRemovedProtons += pINChI_Aux->nNumRemovedProtons;
68          INChI_SegmentAction( pr->sDifSegs[DIFL_F][DIFS_f_FORMULA] )
68     *obsolete* if ind >=0 XML output	embeds val in between XML tags 
68     /* constitution ( dot-disconnected Hill formulas: <formula> ) */
68     int  bIsotopicStereoSp2[TAUT_NUM], bIsotopicStereoSp3[TAUT_NUM];
68     while ( len = WriteOrigAtoms( pCG, orig_inp_data->num_inp_atoms,
68     while ( len = WriteOrigBonds( pCG, orig_inp_data->num_inp_atoms,
68 const int MAX_TAG_NUM = inchi_max((int)IL_MAX_ORD, (int)AL_MAX_ORD);
68 Number of the current atom: 2 until first ";", 3 until 2nd ";", etc.
68 static int Output_INCHI_version_and_kind(	INCHI_IOSTREAM *out_file, 
69                                               print_INCHI_local *pr, 
69                                        INCHI_IOSTREAM_STRING *strbuf,
69                                        INCHI_IOSTREAM_STRING *strbuf,
69                                        INCHI_IOSTREAM_STRING *strbuf,
69                                     bPlainText && !bPlainTextCommnts;
69                                  pSortPrintINChIFlags,save_opt_bits);
69                         int bNoStructLabels, const char *szSdfLabel, 
69                   INCHI_SORT *pINChISortTautAndNonTaut2[][TAUT_NUM], 
69                   INCHI_SORT *pINChISortTautAndNonTaut2[][TAUT_NUM], 
69                 /* remove (+) and leading zeroes from the exponent */
69                 pr.num_components     = pr.num_comp[pr.iCurTautMode];
69             pr->tot_len = str_AuxTautTrans( pCG, nTrans_n, nTrans_s, 
69             pr->tot_len2 = str_FixedH_atoms( pr->pINChISort, strbuf, 
69             pr.pINChISort    = pr.pINChISortTautAndNonTaut[TAUT_NON];
69         bHasIsotopicAtoms[i]      = pr.num_comp[i]                  =
69         CompINChILayers( is, is2, pr.sDifSegs, bFixTranspChargeBug );
69     if ( !strbuf || !(strbuf->pStr) || strbuf->nAllocatedLength<=0 ) 
69     int bFrom = EquVal & (iiSTEREO | iiSTEREO_INV | iiNUMB | iiEQU );
69   Note: . occurs only once and only if radical or 1-character element
69 		while ( j >= 0 &&	iicomp( units2[ unum[j] ], units2[ tmp ] ) > 0  )
70                                                 pr->bOmitRepetitions);
70                                               char *pLF, char *pTAB );
70                                         INCHI_IOSTREAM_STRING *strbuf,
70                                         INCHI_IOSTREAM_STRING *strbuf,
70                                         INCHI_IOSTREAM_STRING *strbuf,
70                                  out_file, log_file, num_input_struct,
70                                  pSortPrintINChIFlags, save_opt_bits);
70                                 parity == AB_PARITY_UNDF?  "?" : "" );
70                     r = "iM";       /* main         = Inv(main iso) */
70                     r = "iM";       /* main iso     = Inv(main iso) */
70                     r = "iM";       /* non-taut     = Inv(main iso) */
70                     r = "iM";       /* non-taut iso = Inv(main iso) */
70                     r = "in";       /* maim         = Inv(non-taut) */
70                     r = "in";       /* maim iso     = Inv(non-taut) */
70                     r = "in";       /* non-taut     = Inv(non-taut) */
70                     r = "in";       /* non-taut iso = Inv(non-taut) */
70                 inchi_ios_print( out_file, "/" ); /* stereo-abs-inv */
70                 memcpy( strbuf->pStr, p+cur_pos, last_pos - cur_pos );
70                 memcpy( strbuf->pStr, p+cur_pos, last_pos - cur_pos );
70                 pr.bIsotopicRelativeStereo[ii]      |= bCurIsoRacemic;
70                 pr.bIsotopicRelativeStereo[ii]     |= bCurIsoRelative;
70                 r = "M";       /* numb non-taut iso = main numb iso */
70                 r = "n";       /* numb non-taut iso = non-taut numb */
70             nNumMovedProtons   += abs(pINChI_Aux->nNumRemovedProtons);
70         Get the two letters encoding the saved InChI creation options.
70         inchi_ios_print( out_file, "%s%s", pr->szTag2, strbuf->pStr );
70         inchi_ios_print( out_file, "%s%s", pr->szTag2, strbuf->pStr );
70         inchi_ios_print( out_file, "%s%s", pr->szTag2, strbuf->pStr );
70         INCHI_OUT_ONLY_AUX_INFO         0x0004    output only Aux Info
70         pr.bAtomEqu[i]            = pr.bTautEqu[i]                   =
70         pr.bRacemicStereo[i]      = pr.bRelativeStereo[i]            =
70     /* connections ( semicolon/dot-disconnected connection tables ) */
70     /* connections ( semicolon/dot-disconnected connection tables ) */
70 	cano_nums	= inchi_calloc( pOrigStruct->num_atoms + 1, sizeof(int)  );
70 int Output_AUXINFO_header_and_normalization_type(	CANON_GLOBALS *pCG, 
70 int Output_AUXINFO_tautomeric_groups_equivalence( CANON_GLOBALS *pCG, 
71                                                  print_INCHI_local *pr,
71                                               ORIG_STRUCT *pOrigStruct,
71                                              INCHI_IOSTREAM *out_file, 
71                                              INCHI_IOSTREAM *out_file, 
71                                          INCHI_IOSTREAM_STRING *strbuf,
71                                          INCHI_IOSTREAM_STRING *strbuf,
71                                         i ++, is ++, is2? is2++:NULL ) 
71                                  int *INCHI_basic_or_INCHI_reconnected,
71                                  SDF_LBL_VAL(szSdfLabel, szSdfValue) );
71                              num_components2, num_non_taut2, num_taut2,
71                             chain_len = get_opposite_sb_atom( at, j, k,
71                             len += sprintf(szCurAtom + len, "%d", val);
71                 e = (int)strtol( szVal+last+1, &q, 10 ); /* exponent */
71                 inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
71                 inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
71                 inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
71                 inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
71                 inchi_ios_print( out_file, "%s%s", strbuf->pStr, pLF );
71                 pr->tot_len = str_StereoAbsInv( pr->pINChISort, strbuf,
71                 pr.num_iso_H[j] += pINChI_Aux->nNumRemovedIsotopicH[j];
71                 r = "m";            /* iso main stereo = main stereo */
71                 r = "m";            /* non-taut stereo = main stereo */
71              len_coord == WriteOrigCoord( orig_inp_data->num_inp_atoms,
71             /* remove trailing zeroes in the range dec_pnt+1..last-1 */
71             bINChIOutputOptionsCur = bINChIOutputOptions0 | bCurOption;
71             for ( n = 0, k = 0; n < MAX_NUM_STEREO_ATOM_NEIGH; n ++ ) {
71           If this INChI is tautomeric and non-tautomeric results exist,
71          !pr->bNonTautIsIdenticalToTaut && /* added 2004-10-04 Fix16 */
71         if ( str_LineEnd( pr->szTag1, &pr->bOverflow, strbuf, -1, 1 ) )
71         int bCurRacemic, bCurRelative, bCurIsoRacemic, bCurIsoRelative;
71         pr.bTautomeric += bTautomericAcid; /* long-range tautomerism */
71     case iiEQU:         /*------------- Atom Equivalence ------------*/
71     if ( INCHI_OUT_FIX_TRANSPOSITION_CHARGE_BUG & bINChIOutputOptions )
71     pr.nTag  = bPlainTextCommnts? 3 : bPlainText? 2 : 0; /* tag type */
71  * Please note that this library is distributed WITHOUT ANY WARRANTIES 
71  * The InChI library and programs are free software developed under the
71 			inchi_strbuf_printf( strbuf, "(%-d,%-d)", u->blist[0], u->blist[1]);
71 #if ( !defined(TARGET_API_LIB) && !defined(TARGET_LIB_FOR_WINCHI) )    
71 /* IL_ALLH_ORD, */    { "/h",  "H_atoms",        "H",              1 },
71 /* IL_ATMS_ORD, */    { "/i",  "atoms",          "atoms",          1 },
71 /* IL_CHRG_ORD, */    { "/q",  "charge",         "charge",         1 },
71 /* IL_CONN_ORD, */    { "/c",  "connections",    "connections",    1 },
71 /* IL_DBND_ORD, */    { "/b",  "dbond",          "dbond",          0 },
71 /* IL_PROT_ORD, */    { "/p",  "protons",        "protons",        0 },
71 /* IL_SP3S_ORD, */    { "/t",  "sp3",            "sp3",            0 },
71 /* IL_VERS_ORD, */    { "" ,   "version",        "version",        1 },
71 /* IL_XCGA_ORD, */    { "/h",  "exchangeable_H", "H-isotopic",     1 },
71 int Output_record_info( INCHI_IOSTREAM *out_file, int num_input_struct,
72                                                  char *pLF, char *pTAB )
72                                                 pr->bSecondNonTautPass, 
72                                                 strbuf, &pr->bOverflow, 
72                                               INCHI_IOSTREAM *out_file, 
72                                       pr->TAUT_MODE, pr->num_components,
72                                   int *INCHI_basic_or_INCHI_reconnected,
72                                 bond_parityNM = inchi_min( p1NM, p2NM );
72                                 pr->num_components, pr->bUseMulipliers);
72                                 pr->num_components, pr->bUseMulipliers);
72                               pr->bOmitRepetitions, pr->bUseMulipliers);
72                       bHardAddRemProton = bTautIsoHNum = bTautIsoAt = 0;
72                 bCurStereo          = bCurStereoSp2    || bCurStereoSp3;
72                 pr->tot_len = str_Sp3( pr->pINChISort, pr->pINChISort2, 
72                 r = "m";       /* equivalence non-taut iso = main equ */
72             if ( (q = strchr(szVal, 'e')) || (q = strchr(szVal, 'E')) ||
72             inchi_strbuf_reset( strbuf ); /*pStr[pr.tot_len=0] = '\0';*/
72             pr->bNonTautIsoIdentifierNotEmpty += pr->bSecondNonTautPass;
72             pr->bNonTautIsoIdentifierNotEmpty += pr->bSecondNonTautPass;
72             pr->tot_len = str_Charge2( pr->pINChISort, pr->pINChISort2, 
72          len_atoms == WriteOrigAtoms( pCG, orig_inp_data->num_inp_atoms,
72          len_bonds == WriteOrigBonds( pCG, orig_inp_data->num_inp_atoms,
72         if ( bEq2 & iiEq2INV ) { /* stereo = Inverted(another stereo) */
72         INCHI_OUT_NO_AUX_INFO           0x0001    do not output Aux Info
72  * Some portions of code were developed/changed by external contributors
72 	compnt_nums	= inchi_calloc( pOrigStruct->num_atoms + 1, sizeof(int)  );
72 static int Output_INCHI_FixedH_layer_and_sublayers( CANON_GLOBALS *pCG, 
73                                                   char *pLF, char *pTAB )
73                                                   print_INCHI_local *pr, 
73                                           * pINChI_Aux->nNumberOfAtoms));
73                                           * pINChI_Aux->nNumberOfAtoms));
73                                           * pINChI_Aux->nNumberOfAtoms));
73                                     /* NB: trailing 0 is also memmoved */
73                                    strbuf, &pr->bOverflow, pr->bOutType, 
73                                  output_file, log_file, num_input_struct,
73                     if ( bCurStereoSp3 && pINChI->Stereo->nCompInv2Abs ) 
73                     last_pos ++; /* include ';' at the end of the line */
73                     last_pos ++; /* include ';' at the end of the line */
73                  (q = strchr(szVal, 'd')) || (q = strchr(szVal, 'D')) ) {
73                 bHasIsoH     += abs(pINChI_Aux->nNumRemovedIsotopicH[j]);
73                 r = "m";       /* inv stereo numb main     = main numb */
73                 r = "m";       /* inv stereo numb non-taut = main numb */
73             inchi_strbuf_printf( strbuf, "%+d", pr->nNumRemovedProtons );
73             nRet = OutputINChI1( pCG, strbuf, pINChISortTautAndNonTaut2, 
73         /* output blank line before /R: in case of bPlainTextCommnts=1 */
73         case (iitNONTAUT | iitISO): /*  equivalence non-taut iso = ... */
73         inchi_strbuf_reset( strbuf ); /* pStr[pr->tot_len = 0] = '\0'; */
73         pr.bIgn_UU_Sp3[i]            = pr.bIgn_UU_Sp2[i]                =
73         pr.bIgn_UU_Sp3_Iso[i]        = pr.bIgn_UU_Sp2_Iso[i]            =
73         pr.bInvStereo[i]             = pr.bInvIsotopicStereo[i]         =
73         pr.bInvStereoOrigNumb[i]     = pr.bInvIsotopicStereoOrigNumb[i] =
73         pr.bIsotopicAtomEqu[i]       = pr.bIsotopicTautEqu[i]           =
73     for ( ; nPathLen && *pathAtom != nNextAtom; nPathLen--,  pathAtom++ )
73     for ( i = 0, is = pr.pINChISort; i < pr.num_components; i ++, is ++ )
73 					inchi_strbuf_printf( strbuf, "(%-d,%-d)", u->blist[0], u->blist[1]);
73 					inchi_strbuf_printf( strbuf, "(%-d,%-d)", u->blist[0], u->blist[1]);
73 					inchi_strbuf_printf( strbuf, "(%-d,%-d)", u->blist[2], u->blist[3]);
73 					inchi_strbuf_printf( strbuf, "(%-d,%-d)", u->blist[2], u->blist[3]);
73 	/* Replace original atom numbers in polymer units with canonical ones */
73 v = undefined stereo Either, single from the current atom to the neighbor
73 V = undefined stereo Either, single from the neighbor to the current atom
74                                                     char *pLF, char *pTAB,
74                                                     print_INCHI_local *pr,
74                                             INCHI_IOSTREAM_STRING *strbuf,
74                                      pINChI_Aux->nNumRemovedIsotopicH[1] +
74                                      pINChI_Aux->nNumRemovedIsotopicH[2]);
74                               pr->num_components, pr->bSecondNonTautPass, 
74                             chain_len2 = get_opposite_sb_atom( at, j2, k2,
74                          j == TAUT_NON && 0 <= (jj = GET_II(OUT_T1,is)) &&
74                     bTautIsoHNum += (pINChI_Aux->nNumRemovedIsotopicH[0] +
74                 len += sprintf( szCurAtom + len, "%d", val > 0? val : 0 );
74                 r = "m";       /* inv stereo iso numb main = main numb  */
74             /* a non-trivial transposition does exist; output start tag */
74             pr->tot_len = str_AuxIsoEqu( pr->pINChISort, pr->pINChISort2, 
74         for ( i = 0, j = -1, bit = 1; i < MAX_TAG_NUM; i ++, bit <<= 1 ) {
74         pr->tot_len = str_AuxNumb(  pCG, pr->pINChISort, pr->pINChISort2, 
74         pr.bIsotopicRelativeStereo[i] = pr.bIsotopicRelativeStereo[i]    =
74     int  chain_len2, pnxt_atom2, pinxt2cur2, pinxt_sb_parity_ord2, m1, m2;
74     pr.bIsotopic	= pr.bTautomeric = pr.bNonTautomeric = bTautomericAcid = 
74     pr.num_components = num_components2[INCHI_basic_or_INCHI_reconnected];
74 					inchi_strbuf_printf( strbuf, "(%-d)(%-d)", u->blist[0], u->blist[2]);
74 					inchi_strbuf_printf( strbuf, "(%-d)(%-d)", u->blist[2], u->blist[0]);
74 int Output_AUXINFO_charges_radicals_unusual_valences( CANON_GLOBALS *pCG, 
74 static int *is_in_the_ilist( int *pathAtom, int nNextAtom, int nPathLen );
75                                                            num_components2,
75                                                     char *pLF, char *pTAB )
75                                                     int num_components2[], 
75                                                     int num_components2[], 
75                                                     int num_components2[], 
75                                                     print_INCHI_local *pr, 
75                                                     print_INCHI_local *pr, 
75                                                     print_INCHI_local *pr, 
75                                              INCHI_IOSTREAM_STRING *strbuf,
75                                              INCHI_IOSTREAM_STRING *strbuf,
75                                          pr->TAUT_MODE, pr->num_components,
75                                         pr->TAUT_MODE, pr->num_components);
75                                    pr->num_components, pr->bUseMulipliers);
75                                  num_components2, num_non_taut2, num_taut2,
75                                  num_components2, num_non_taut2, num_taut2,
75                             (0 != memcmp( pINChI_Aux->nOrigAtNosInCanonOrd,
75                         for ( kc = 0; kc < at[pcur_atom].valence; kc ++ ) {
75                         for ( kc = 0; kc < at[pnxt_atom].valence; kc ++ ) {
75                     r = "iN";       /* maim         = Inv(non-taut iso ) */
75                     r = "iN";       /* maim         = Inv(non-taut iso ) */
75                     r = "iN";       /* non-taut     = Inv(non-taut iso ) */
75                     r = "iN";       /* non-taut iso = Inv(non-taut iso ) */
75                     r = "m";       /* main         = (inverted aux) main */
75                     r = "m";       /* non-taut     = (inverted aux) main */
75                 bCurIsoStereo       = bCurIsoStereoSp2 || bCurIsoStereoSp3;
75                 r = "m";            /* iso non-taut stereo = main stereo */
75             if ( (pINChI = is->pINChI[jj]) && pINChI->nNumberOfAtoms > 0 ) 
75             if ( str_LineEnd( pr->szTag1, &pr->bOverflow, strbuf, -2, 1 ) )
75             if ( str_LineEnd( pr->szTag1, &pr->bOverflow, strbuf, -2, 1 ) )
75             pr->bNonTautNonIsoIdentifierNotEmpty += pr->bSecondNonTautPass;
75             pr->bNonTautNonIsoIdentifierNotEmpty += pr->bSecondNonTautPass;
75             pr->bNonTautNonIsoIdentifierNotEmpty += pr->bSecondNonTautPass;
75     if ( !pr->bSecondNonTautPass && pr->bChargesRadVal[pr->iCurTautMode] ) 
75     pr.iCurTautMode = pr.bOutType == OUT_N1? TAUT_NON:  /* only non-taut */
75  * This library is free software; you can redistribute it and/or modify it 
75 void GetSaveOptLetters(unsigned char save_opt_bits, char* let1, char* let2)
76                                                            &pr, pLF, pTAB );
76                                                     char *pLF, char *pTAB );
76                                                     int *then_goto_repeat );
76                                                   INCHI_IOSTREAM *out_file, 
76                                               INCHI_IOSTREAM_STRING *strbuf,
76                                             FLAG_SORT_PRINT_NO_NFIX_H_REC ))
76                                       (pINChI->Stereo->nCompInv2Abs != 0) &&
76                                       (pINChI->Stereo->nCompInv2Abs != 0) &&
76                                       strbuf, &pr->bOverflow, pr->bOutType, 
76                                     pr->num_components, pr->bUseMulipliers);
76                                  INCHI_REC, NULL, 0 /*bDisconnectedCoord*/, 
76                              bAbcNumbers, bCtPredecessors, bNoStructLabels, 
76                     /* detect presence of constitutional equivalence onfo */
76                 pr->bNonTautIsoIdentifierNotEmpty += pr->bSecondNonTautPass;
76                 r = "M";       /* equivalence non-taut iso = main iso equ */
76                 r = "n";       /* equivalence non-taut iso = non-taut equ */
76             if ( pr->bPlainTextTags == 1 ) inchi_ios_print( out_file, "/" );
76             if ( pr->bPlainTextTags == 1 ) inchi_ios_print( out_file, "/" );
76             inchi_ios_print( out_file, "//" );   /* inv or racemic stereo */
76             pr->pINChISort         = pr->pINChISortTautAndNonTaut[TAUT_YES];
76           At this point the INChI_Aux part of the output has been completed.
76         /*-- Original atom numbers in order of isotopic canonical numbers */
76         case (iitNONTAUT | iitISO): /* inv stereo numb non-taut iso = ... */
76         if ( pr.bOutType == OUT_TN && pr.bTautomeric && pr.bNonTautomeric &&
76         if ( pr.bOutType == OUT_TN && pr.bTautomeric && pr.bNonTautomeric ) 
76         pr.bChargesRadVal[i]         = pr.bOrigCoord[i]                 = 0;
76     if ( !(szSdfLabel && szSdfLabel[0]) && !(szSdfValue && szSdfValue[0]) ) 
76     int  bStereoAbsInverted[TAUT_NUM], bIsotopicStereoAbsInverted[TAUT_NUM];
76 void set_line_separators( int bINChIOutputOptions, char **pLF, char **pTAB )
77                                                              num_components2,
77                                                             &pr, pLF, pTAB );
77                                                       char *pLF, char *pTAB )
77                                                       print_INCHI_local *pr, 
77                                                     int bINChIOutputOptions, 
77                                                     int bINChIOutputOptions, 
77                                                 pr->bOutType, pr->TAUT_MODE, 
77                                          pr->num_components, pr->bAbcNumbers,
77                      at[neigh].orig_at_number  ==  at[j].p_orig_at_num[n] ) {
77                     continue; /* deleted H(+) in tautomeric representation */
77                     r = "m";        /* non-taut iso  = (inverted aux) main */
77                 /* Fix 11: missing /s1 if only isotopic stereo is inverted */
77                 len += sprintf( szCurAtom + len, "%s%s", len == len0? ".":"",
77                 r = "m";       /* inv stereo numb non-taut iso = main numb */
77                 r = "n";       /* inv stereo numb non-taut = non-taut numb */
77             inchi_strbuf_reset( strbuf ); pr->tot_len = 0; /* open H-fixed */
77             pr->tot_len = str_AuxInvIsoSp3( pr->pINChISort, pr->pINChISort2, 
77          OUT_NT: x[TAUT_NON] refers to non-taut representations of tautomeric
77     /* SaveOptBits layout: {unused|unused|Ket|15T|RecMet|FixedH|SUU|SLUUD} */
77     case iiNUMB:           /*------------- Canonical Numbering ------------*/
77     intermediate_result = Output_INCHI_isotopic_layer( pCG, out_file, strbuf,
77     intermediate_result = Output_INCHI_polymer_layer( pCG, out_file, strbuf, 
77     max_num_comp   = inchi_max(pr.num_comp[TAUT_NON], pr.num_comp[TAUT_YES]);
77     Output bonds in ascending order of the neighboring atom original numbers 
77  * auspices of the International Union of Pure and Applied Chemistry (IUPAC).
77 static int Output_AUXINFO_header_and_normalization_type( CANON_GLOBALS *pCG, 
77 static int Output_AUXINFO_tautomeric_groups_equivalence( CANON_GLOBALS *pCG, 
77 static int WriteOrigCoord( int num_inp_atoms, MOL_COORD *szMolCoord, int *i, 
78                                                                    /* items */
78                                                              &pr, pLF, pTAB );
78                                                     INCHI_IOSTREAM *out_file, 
78                                                     INCHI_IOSTREAM *out_file, 
78                                                     INCHI_IOSTREAM *out_file, 
78                                                     INCHI_IOSTREAM *out_file, 
78                                           pINChI_Aux->nOrigAtNosInCanonOrdInv,
78                                         int *INCHI_basic_or_INCHI_reconnected,
78                                         int *INCHI_basic_or_INCHI_reconnected,
78                                         int *INCHI_basic_or_INCHI_reconnected,
78                                     /* special case: removed isolated H(+): */
78                                 pr->bSecondNonTautPass, pr->bOmitRepetitions);
78                             (0 != memcmp( pINChI_Aux->nOrigAtNosInCanonOrdInv,
78                 (pr->tot_len) += MakeDelim( p_stereo, strbuf, &pr->bOverflow);
78                 /* a non-trivial transposition does exist; output start tag */
78                 /* search backward for the nearest first bond delimiter ";" */
78                 if ( is_in_the_list( at[j].neighbor, neigh, at[j].valence ) &&
78                 memcpy( szBuf + cur_len, szCurCoord, len * sizeof(szBuf[0]) );
78                 memmove( buf->pStr+tag_len, buf->pStr, buf->nUsedLength + 1 );
78                 pr->tot_len2 = str_IsoAtoms( pr->pINChISort, pr->pINChISort2, 
78                 pr.pINChISort         = pr.pINChISortTautAndNonTaut[TAUT_YES];
78                 strbuf->pStr[strbuf->nUsedLength + last_pos - cur_pos] = '\0';
78             if ( p = (char *)memchr( szCurCoord, '\0', sizeof(szCurCoord)) ) {
78             pr->tot_len2 = str_HillFormula2( pr->pINChISort, pr->pINChISort2, 
78         inchi_ios_print( out_file, "%sStructure: %d", pLF, num_input_struct );
78         inchi_ios_print( out_file, "\nFATAL ERROR: Output buffer overflow\n");
78         pr->tot_len = str_AuxInvSp3( pr->pINChISort, pr->pINChISort2, strbuf, 
78 				/* place forwad bond's end which lies outside polymeric unit (i.e., '*' */
78 			if ( u->real_kind == POLYMER_UNIT_KIND_STRUCTURE_BASED_SRU_WITH_TWO_STARS )
78 int Output_INCHI_charge_and_removed_added_protons_layers( CANON_GLOBALS *pCG, 
78 static int Output_record_info(	INCHI_IOSTREAM *out_file, int num_input_struct,
79                                                                num_components2,
79                                          int *INCHI_basic_or_INCHI_reconnected,
79                                          int *INCHI_basic_or_INCHI_reconnected,
79                                          int *INCHI_basic_or_INCHI_reconnected,
79                                          strbuf, &pr->bOverflow, pr->bOutType, 
79                                          strbuf, &pr->bOverflow, pr->bOutType, 
79                     pr->tot_len = str_IsoSp2( pr->pINChISort, pr->pINChISort2, 
79                     pr->tot_len = str_IsoSp3( pr->pINChISort, pr->pINChISort2, 
79                     pr->tot_len = str_IsoStereoAbsInv( pr->pINChISort, strbuf, 
79                 bCurRacemic         = bRequestedRacemicStereo && bCurStereoSp3;
79                 pr->bNonTautNonIsoIdentifierNotEmpty += pr->bSecondNonTautPass;
79                 pr->bNonTautNonIsoIdentifierNotEmpty += pr->bSecondNonTautPass;
79                 pr->bNonTautNonIsoIdentifierNotEmpty += pr->bSecondNonTautPass;
79                 pr->bNonTautNonIsoIdentifierNotEmpty += pr->bSecondNonTautPass;
79                 r = "M";            /* iso non-taut stereo = main iso stereo */
79                 r = "n";            /* iso non-taut stereo = non-taut stereo */
79                 while ( cur_pos < last_pos && !isupper( UCINT p[last_pos] ) ) {
79             /* the second (non-taut) output has been done; restore variables */
79     if ( bDisconnectedCoord && INCHI_basic_or_INCHI_reconnected == INCHI_BAS &&
79     is2 = (pr.bOutType== OUT_TN)? pr.pINChISortTautAndNonTaut[TAUT_NON] : NULL;
79 				if ( u->real_kind == POLYMER_UNIT_KIND_STRUCTURE_BASED_SRU_WITH_TWO_STARS )
79 				if ( u->real_kind == POLYMER_UNIT_KIND_STRUCTURE_BASED_SRU_WITH_TWO_STARS )
80                                                                     /* stereo */
80                                                                &pr, pLF, pTAB );
80                                                          print_INCHI_local *pr, 
80                                                       INCHI_IOSTREAM *out_file, 
80                                                    pINChI_Aux->nNumberOfAtoms));
80                                                   INCHI_IOSTREAM_STRING *strbuf,
80                                           strbuf, &pr->bOverflow, pr->bOutType, 
80                                  bAbcNumbers, bCtPredecessors, bNoStructLabels, 
80                                  bAbcNumbers, bCtPredecessors, bNoStructLabels, 
80                                 pr->bOutType, pr->TAUT_MODE, pr->num_components,
80                     pr->bNonTautIsoIdentifierNotEmpty += pr->bSecondNonTautPass;
80                     pr->bNonTautIsoIdentifierNotEmpty += pr->bSecondNonTautPass;
80                     pr->bNonTautIsoIdentifierNotEmpty += pr->bSecondNonTautPass;
80                     pr->bNonTautIsoIdentifierNotEmpty += pr->bSecondNonTautPass;
80                     pr->tot_len += MakeDelim( p_stereo, strbuf, &pr->bOverflow);
80                     r = "M";       /* non-taut iso  = (inverted aux) main iso */
80                     r = "n";       /* non-taut iso  = (inverted aux) non-taut */
80                   + 1 + sizeof(x_text)-1 + 1 + 1 + strlen(szErrorText) + 1 + 1);
80                 /* search backward for the nearest first coord. delimiter ";" */
80                 /*len += sprintf( szCurBonds + len, "%c%d", bond_char, val+1);*/
80             /*if ( pr->bPlainTextTags == 1 ) inchi_ios_print( out_file, "/" );*/
80             pr->tot_len = str_AuxIsoNumb( pCG, pr->pINChISort, pr->pINChISort2, 
80             pr.bNonTautIsIdenticalToTaut && !CompINChITautVsNonTaut(is, is2, 1);
80         /* in wINChI window, separate AuxInfo: from InChIKey: with blank line */
80     pr.bTautomericOutputAllowed = (pr.bOutType==OUT_T1 || pr.bOutType== OUT_TN);
80 	szGetTag( IdentLbl, pr->nTag,  pr->bTag1 = IL_CONN, pr->szTag1, &pr->bAlways );
80 	szGetTag( IdentLbl, pr->nTag,  pr->bTag1 = IL_CONN, pr->szTag1, &pr->bAlways );
81                                                          char *pLF, char *pTAB );
81                                          pr->num_components, pr->bUseMulipliers);
81                                       pINChI->Stereo->nNumberOfStereoCenters : 0;
81                                    pr->bSecondNonTautPass, pr->bOmitRepetitions);
81                                    pr->bSecondNonTautPass, pr->bOmitRepetitions);
81                         if ( neigh1 < num_inp_atoms && neigh2 < num_inp_atoms ) {
81                     bCurIsoStereoSp3  = bCurIsoRelative   ? bCurIsoStereoSp3 : 0;
81                 bCurRelative        =  bRequestedRelativeStereo && bCurStereoSp3;
81                 r = "M";       /* inv stereo numb non-taut iso = main numb iso */
81                 r = "M";      /* inv stereo iso numb main = isotopic main numb */
81                 r = "n";       /* inv stereo numb non-taut iso = non-taut numb */
81             const char *p_stereo = pr->bRelativeStereo[pr->iCurTautMode]? x_rel :
81         for ( i = 0, j = -1, bit = 1, num=0; i < MAX_TAG_NUM; i ++, bit <<= 1 ) {
81         if ( pr->tot_len != pr->tot_len2 ) { /* 2004-06-21: never output empty */
81         if ( pr->tot_len != pr->tot_len2 ) { /* 2004-06-21: never output empty */
81         intermediate_result = Output_AUXINFO_tautomeric_groups_equivalence( pCG, 
81     pr.bNonTautIsIdenticalToTaut = pr.bNonTautIsIdenticalToTaut && !bTautIsoHNum;
81 	intermediate_result = Output_INCHI_main_layer_hydrogens( pCG, out_file, strbuf, 
81 int Output_AUXINFO_original_numbers_and_equivalence_classes( CANON_GLOBALS *pCG, 
81 static int Output_AUXINFO_charges_radicals_unusual_valences( CANON_GLOBALS *pCG, 
82                                                                        /* items */
82                                                                     /* isotopic */
82                                                     INCHI_IOSTREAM_STRING *strbuf,
82                                                     INCHI_IOSTREAM_STRING *strbuf,
82                                                     INCHI_IOSTREAM_STRING *strbuf,
82                                                     INCHI_IOSTREAM_STRING *strbuf,
82                                    pr->TAUT_MODE, pr->num_components, pr->bRelRac,
82                                   (sd->bChiralFlag & FLAG_INP_AT_CHIRAL)?    "c" :
82                           * x[TAUT_NON]: non-taut only if tautomeric is present */
82          INChI_SegmentAction( pr->sDifSegs[pr->nCurINChISegment][DIFS_s_STYPE] ) )
82          TAUT_YES  => tautomeric only (if no tautomeric components then no output;
82         /*  isotopic #1:  composition -- atoms -- do not output in xml if empty */
82         INCHI_OUT_SHORT_AUX_INFO        0x0002    output short version of Aux Info
82         memcpy( szBuf + len_buf, szVal, len ); /* does not copy zero termination*/
82     intermediate_result = Output_INCHI_main_layer_formula( pCG, out_file, strbuf, 
82 #define OUT_NT              2    /* only non-taut representations of tautomeric */
82 #ifndef OUT_TN    /* defined in mode.h; quoted here for reference purposes only */
83                                                             char *pLF, char *pTAB )
83                                                             int num_components2[], 
83                                                             print_INCHI_local *pr, 
83                                                          INCHI_IOSTREAM *out_file, 
83                                              int *INCHI_basic_or_INCHI_reconnected,
83                                            pr->num_components, pr->bUseMulipliers);
83                                           pINChI_Aux->nIsotopicOrigAtNosInCanonOrd,
83                                    pr->bOutType, pr->TAUT_MODE, pr->num_components,
83                                    pr->bOutType, pr->TAUT_MODE, pr->num_components,
83                               strbuf, &pr->bOverflow, pr->bOutType, pr->TAUT_MODE, 
83                             (0 != memcmp( pINChI_Aux->nIsotopicOrigAtNosInCanonOrd,
83                         (bINChIOutputOptions & INCHI_OUT_WINCHI_WINDOW) ? "\n":"");
83                         pr.bIsotopicOrigNumb[ii] |= bCurHasIsoStereo && /* Fix14 */
83                 /* the second (non-taut) output has been done; restore variables */
83                 /*strbuf->nUsedLength = strbuf->nUsedLength + last_pos - cur_pos;*/
83                 if ( chain_len == 1 && chain_len2 == 1 ||  /* regular stereobond */
83             pr->tot_len = str_AuxInvSp3Numb( pCG, pr->pINChISort, pr->pINChISort2, 
83         intermediate_result = Output_AUXINFO_isotopic_info( pCG, out_file, strbuf, 
83     if ( INChI_SegmentAction( pr->sDifSegs[pr->nCurINChISegment][DIFS_i_IATOMS] ) )
83 	intermediate_result = Output_INCHI_main_layer_connections( pCG, out_file, strbuf, 
83 #define OUT_TN              3    /* tautomeric if present otherwise non-tautomeric;
83 /* IL_TRNS_ORD, */    { "/o",  "transposition",  "transposition",  0 }, /* order */
83 static void GetSaveOptLetters(unsigned char save_opt_bits, char* let1, char* let2);
84                                                       INCHI_IOSTREAM_STRING *strbuf,
84                                             pr->num_components, pr->bUseMulipliers);
84                                       (pINChI->StereoIsotopic->nCompInv2Abs != 0) &&
84                                       (pINChI->StereoIsotopic->nCompInv2Abs != 0) &&
84                                       pr->bSecondNonTautPass, pr->bOmitRepetitions);
84                                   orig_inp_data->at, &i, szBuf, sizeof(szBuf), sd)) 
84                             if ( bHasMetal && is_el_a_metal( at[neigh].el_number ) )
84                             if ( bHasMetal && is_el_a_metal( at[neigh].el_number ) )
84                     if ( bCurIsoStereoSp3 && pINChI->StereoIsotopic->nCompInv2Abs ) 
84                  x[TAUT_NON] refers to non-taut representations of tautomeric       
84                 case OUT_N1: /* x[TAUT_NON]: non-tautomeric only -- never happens */
84                 r = "im";      /* inv stereo iso numb main = InvStereo(main) numb */
84             if ( is_ok && b_self <= 1 && b_self + k == MAX_NUM_STEREO_ATOM_NEIGH ) {
84             inchi_ios_print( out_file, "///" ); /* isotopic composition, sp2, sp3 */
84          INChI_SegmentAction( pr->sDifSegs[pr->nCurINChISegment][DIFS_m_SP3INV] ) ||
84          INChI_SegmentAction( pr->sDifSegs[pr->nCurINChISegment][DIFS_t_SATOMS] ) ||
84          OUT_T1: x[TAUT_YES] refers to tautomeric if exists otherwise non-tautomeric
84          OUT_TN: x[TAUT_YES] refers to tautomeric if exists otherwise non-tautomeric
84         ( 0==(bINChIOutputOptions & INCHI_OUT_STDINCHI) )	/* not std-InChI output */
84         /*  isotopic #1a:  composition -- exchangeable isotopic H (mobile H only) */
84         /* 2. Compare to the previous component if (1) failed to find equivalence */
84         /* 2. Compare to the previous component if (1) failed to find equivalence */
84         /* find and print non-tautomeric components transposition, if non-trivial */
84     if ( INChI_SegmentAction( pr->sDifSegs[pr->nCurINChISegment][DIFS_b_SBONDS] ) ||
84 /* IL_STER_ORD, */    { "/",   "stereo",         "stereo",         0 }, /* stereo */
84 char *szGetTag(const INCHI_TAG *Tag, int nTag, int bTag, char *szTag, int *bAlways);
85                                                               print_INCHI_local *pr, 
85                                            pr->bOmitRepetitions, pr->bUseMulipliers);
85                                           sizeof(pINChI_Aux->nOrigAtNosInCanonOrd[0])
85                                       (pINChI->Stereo->nNumberOfStereoCenters > 0 ) ?
85                              INCHI_IOSTREAM *out_file, INCHI_IOSTREAM_STRING *strbuf,
85                          !is->pINChI[jj]->bDeleted && !is->pINChI[jj]->lenTautomer ) 
85                         bCurIsoStereoSp3  = bCurIsoRacemic > 1? bCurIsoStereoSp3 : 0;
85                     | (pr.bAbcNumbers && bCtPredecessors? CT_MODE_ABC_NUM_CLOSURES:0)
85                     p1   = SB_PARITY_1(at[pcur_atom].sb_parity[picur_sb_parity_ord]);
85                     p1NM = SB_PARITY_2(at[pcur_atom].sb_parity[picur_sb_parity_ord]);
85                     p2   = SB_PARITY_1(at[pnxt_atom].sb_parity[pinxt_sb_parity_ord]);
85                     p2NM = SB_PARITY_2(at[pnxt_atom].sb_parity[pinxt_sb_parity_ord]);
85                 len += sprintf( szCurAtom + len, "%si%d", len == len0? ".":"", val );
85                 r = "N";       /* inv stereo numb non-taut iso = non-taut iso numb */
85             "Cannot allocate output buffer. No output for structure #%d.%s%s%s%s\n", 
85          (bINChIOutputOptions & INCHI_OUT_EMBED_REC) && num_components2[INCHI_REC] ) 
85         i = INChI_SegmentAction( pr->sDifSegs[pr->nCurINChISegment][DIFS_t_SATOMS] );
85         inchi_ios_print( out_file, "%sStructure: %d.%s%s%s%s", pLF, num_input_struct,
85         intermediate_result = Output_AUXINFO_charges_radicals_unusual_valences( pCG, 
85         szGetTag( AuxLbl, pr->nTag,  pr->bTag1 = AL_NORM, pr->szTag1, &pr->bAlways );
85         szGetTag( AuxLbl, pr->nTag,  pr->bTag1 = AL_VERS, pr->szTag1, &pr->bAlways );
85     int  bPlainTabbedOutput	= 0 != (bINChIOutputOptions & INCHI_OUT_TABBED_OUTPUT) &&
85     intermediate_result = Output_INCHI_charge_and_removed_added_protons_layers( pCG, 
85 #define OUT_T1              1    /* tautomeric if present otherwise non-tautomeric */
85 /* AL_REC__ORD, */    { "/R:",  "reconnected bond(s) to metal(s) part",  "",      1 }
85 /* IL_FIXH_ORD, */    { "/",   "fixed_H",        "fixed-H",        0 }, /* fixed H */
85 /* IL_HFIX_ORD, */    { "/h",  "H_fixed" ,       "H-fixed" ,       1 }, /* fixed-H */
85 char *szGetTag( const INCHI_TAG *Tag, int nTag, int bTag, char *szTag, int *bAlways )
85 static int Output_INCHI_charge_and_removed_added_protons_layers( CANON_GLOBALS *pCG, 
86                                                                     /* fixed H only */
86                                                               char *pLF, char *pTAB );
86                                                             INCHI_IOSTREAM *out_file, 
86                                                        pINChI_Aux->nNumberOfTGroups));
86                                           pINChI_Aux->nIsotopicOrigAtNosInCanonOrdInv,
86                                       (pINChI->Stereo->nNumberOfStereoCenters > 1 ) &&
86                                   orig_inp_data->at, &i, szBuf, sizeof(szBuf), NULL)) 
86                               * x[TAUT_NON]: non-taut only if tautomeric is present */
86                              bOutputType, bINChIOutputOptions | INCHI_OUT_NO_AUX_INFO,
86                 /* set correct num components for the reversibility info 02-10-2005 */
86                 inchi_ios_print( out_file, "/" );  /* no abs, inv or racemic stereo */
86                 r = "im";      /* inv stereo numb non-taut =  InvStereo(main) numb  */
86              INChI_SegmentAction( pr->sDifSegs[pr->nCurINChISegment][DIFS_s_STYPE] ) )
86             if ( pr->bPlainTextTags == 1 ) inchi_ios_print( out_file, "/" ); /* sp2 */
86             if ( pr->bPlainTextTags == 1 ) inchi_ios_print( out_file, "/" ); /* sp3 */
86         pr.pINChISortTautAndNonTaut[pr.bTautomericOutputAllowed? TAUT_YES : TAUT_NON];
86     /* if InChI Fixed-H isotopic is empty, then do not output corresponding AuxInfo */
86     case ( iiNUMB | iiSTEREO_INV): /*------------- Inv Stereo Numbering ------------*/
86     static const int  add_tag_len = sizeof(x_line_closing)-1 + sizeof(x_close_line)-1;
86 /* AL_AEQU_ORD, */    { "/E:",   "atom_equivalence",       "atom.equivalence",    0 },
86 /* AL_ANBR_ORD, */    { "/N:",   "original_atom_numbers",  "atom.orig-nbr",       1 },
86 /* AL_ATMR_ORD, */    { "/rA:",  "atoms",                  "atoms",               0 },
86 /* AL_BNDR_ORD, */    { "/rB:",  "bonds",                  "bonds",               0 },
86 /* AL_CRV__ORD, */    { "/CRV:", "charge_radical_valence", "charges-rad-val",     0 },
86 /* AL_FIXN_ORD, */    { "/F:",   "original_atom_numbers",  "atom.orig-nbr",       1 },
86 /* AL_GEQU_ORD, */    { "/gE:",  "group_equivalence",      "group.equivalence",   0 },
86 /* AL_ISON_ORD, */    { "/I:",   "original_atom_numbers",  "atom.orig-nbr",       1 },
86 /* AL_NORM_ORD, */    { "/",     "normalization_type",     "norm-type",           1 },
86 /* AL_SP3I_ORD, */    { "/it:",  "sp3",                    "sp3",                 0 },
86 /* AL_SP3N_ORD, */    { "/iN:",  "original_atom_numbers",  "atom.orig-nbr",       0 },
86 /* AL_VERS_ORD, */    { "",      "version",                "version",             1 },
86 /* AL_XYZR_ORD, */    { "/rC:",  "xyz",                    "xyz",                 0 },
86 /* IL_INVS_ORD, */    { "/m",  "sp3:inverted",   "abs.inverted",   0 }, /* mirrored */
86 /* IL_ISOT_ORD, */    { "/",   "isotopic",       "isotopic",       0 }, /* isotopic */
87                                                          INCHI_IOSTREAM_STRING *strbuf,
87                                                  pINChI_Aux->nOrigAtNosInCanonOrdInv &&
87                                            &pr->bOverflow, pr->bOutType, pr->TAUT_MODE,
87                                          pr->bSecondNonTautPass, pr->bOmitRepetitions);
87                                          pr->bSecondNonTautPass, pr->bOmitRepetitions, 
87                     bWellDef  = ATOM_PARITY_WELL_DEF(p1)   && ATOM_PARITY_WELL_DEF(p2);
87                     int p1, p2, p1NM, p2NM, neigh, neigh1, neigh2, bHasMetal, bWellDef;
87             case OUT_NT: /* x[TAUT_NON]: only non-taut representations of tautomeric */
87           |     normal  or disconected metal    |      reconnected bonds to metal     |
87           |_____________________________________|_____________________________________|
87         Each of options is a binary switch {ON,OFF}, so it totals to 2*2*2*2=16 values 
87         szGetTag( IdentLbl, pr->nTag,  pr->bTag1 = IL_ALLH, pr->szTag1, &pr->bAlways );
87         szGetTag( IdentLbl, pr->nTag,  pr->bTag1 = IL_ALLH, pr->szTag1, &pr->bAlways );
88                                                               INCHI_IOSTREAM *out_file, 
88                                                   (bond_parity == AB_PARITY_EVEN)? "+" :
88                                                   (bond_parity == AB_PARITY_ODD)?  "-" :
88                                                   (bond_parity == AB_PARITY_UNKN)? "u" :
88                                                   pINChI_Aux->nOrigAtNosInCanonOrdInv &&
88                                           pr->bSecondNonTautPass, pr->bOmitRepetitions, 
88                                           sizeof(pINChI_Aux->nOrigAtNosInCanonOrdInv[0])
88                                         pr->bOutType, pr->TAUT_MODE, pr->num_components,
88                                     strbuf, &pr->bOverflow, pr->bOutType, pr->TAUT_MODE,
88                                    pr->bRacemicStereo[pr->iCurTautMode] ? x_rac : x_abs;
88                                   (sd->bChiralFlag & FLAG_INP_AT_NONCHIRAL)? "n" : "" );
88                             bTautAndNonTaut += (!is->pINChI[jj]->bDeleted && HAS_N(is));
88                         pr.bInvStereoOrigNumb[ii] |= pINChI_Aux->nOrigAtNosInCanonOrd &&
88                 r = "im";      /* inv stereo numb non-taut iso = InvStereo(main) numb */
88              INChI_SegmentAction( pr->sDifSegs[pr->nCurINChISegment][DIFS_m_SP3INV] ) ||
88              INChI_SegmentAction( pr->sDifSegs[pr->nCurINChISegment][DIFS_t_SATOMS] ) ||
88             /* find and print non-tautomeric components transposition, if non-trivial */
88             case OUT_TN: /* x[TAUT_YES]: tautomeric if present otherwise non-tautomeric;
88          INCHI_SEGM_FILL == INChI_SegmentAction( pr->sDifSegs[DIFL_F][DIFS_o_TRANSP] )) 
88          TAUT_NON  => only non-tautomeric output (if no non-taut present then no output;
88         if ( INChI_SegmentAction( pr->sDifSegs[pr->nCurINChISegment][DIFS_b_SBONDS] ) ||
88         if ( str_LineEnd( pr->szTag1, &pr->bOverflow, strbuf, -1, pr->bPlainTextTags ) )
88         if ( str_LineEnd( pr->szTag1, &pr->bOverflow, strbuf, -1, pr->bPlainTextTags ) )
88         if ( str_LineEnd( pr->szTag1, &pr->bOverflow, strbuf, -1, pr->bPlainTextTags ) )
88         if ( str_LineEnd( pr->szTag1, &pr->bOverflow, strbuf, -1, pr->bPlainTextTags ) )
88         if ( str_LineEnd( pr->szTag1, &pr->bOverflow, strbuf, -1, pr->bPlainTextTags ) )
88         if ( str_LineEnd( pr->szTag1, &pr->bOverflow, strbuf, -1, pr->bPlainTextTags ) )
88         if ( str_LineEnd( pr->szTag1, &pr->bOverflow, strbuf, -2, pr->bPlainTextTags ) )
88         if ( str_LineEnd( pr->szTag1, &pr->bOverflow, strbuf, -2, pr->bPlainTextTags ) )
88         if ( str_LineEnd( pr->szTag2, &pr->bOverflow, strbuf, -1, pr->bPlainTextTags ) )
88         intermediate_result = Output_AUXINFO_reversibility_info( pCG, out_file, strbuf, 
88         reservation for future needs: the 2nd memo char may accommodate two more ON/OFF 
88     int  bPlainTextCommnts = 0 != (bINChIOutputOptions & INCHI_OUT_PLAIN_TEXT_COMMENTS);
88     int  bPlainTextCommnts	= 0 != (bINChIOutputOptions & INCHI_OUT_PLAIN_TEXT_COMMENTS);
88 static int Output_AUXINFO_original_numbers_and_equivalence_classes( CANON_GLOBALS *pCG, 
88 static int WriteOrigAtoms( CANON_GLOBALS *pCG, int num_inp_atoms, inp_ATOM *at, int *i, 
88 static int WriteOrigBonds( CANON_GLOBALS *pCG, int num_inp_atoms, inp_ATOM *at, int *i, 
89                                                                        /* fixed-H only */
89                                             &pr->bOverflow, pr->bOutType, pr->ATOM_MODE, 
89                                           &pnxt_atom, &pinxt2cur, &pinxt_sb_parity_ord );
89                                           pr->TAUT_MODE, pr->num_components, pr->bRelRac,
89                             (bINChIOutputOptions & INCHI_OUT_NO_AUX_INFO)? "\n" : pTAB );
89                             if ( ATOM_PARITY_WELL_DEF(p1) && ATOM_PARITY_WELL_DEF(p2) ) {
89                     bHasMetal = ATOM_PARITY_WELL_DEF(p1NM) && ATOM_PARITY_WELL_DEF(p2NM);
89                 /* present isotopic H + their possible positions AND/OR isotopic atoms */
89                 inchi_ios_print( out_file, "////" ); /* sp3, sp2, abs-inv, stereo.type */
89             /* fst = (first mantissa digit); fst=1 if the sign is present, otherwise 0 */
89             /* main control flow comes here: requested both mobile and fixed H results */
89             szGetTag( AuxLbl, pr->nTag,  pr->bTag1 = AL_REC_, pr->szTag1, &pr->bAlways );
89           |----------+-------+--------+---------|----------+-------+--------+---------|  
89           |----------+-------+--------+---------|----------+-------+--------+---------|  
89           |                                     |                                     |  
89           |          |       |        |         |          |       |        |         |  
89           |        mobile-H  |   fixed-H        |        mobile-H  |   fixed-H        |  
89           | non-iso- | iso-  | fix-   | iso-    | non-iso- | iso-  | fix-   | iso-    |  
89         pr->tot_len2 = str_H_atoms( pr->pINChISort, strbuf, &pr->bOverflow, pr->bOutType,
89         pr->tot_len2 = str_H_atoms( pr->pINChISort, strbuf, &pr->bOverflow, pr->bOutType,
89     intermediate_result = Output_INCHI_FixedH_layer_and_sublayers( pCG, out_file, strbuf,
89   1.12Beta/FML       /i      /f[FML]  /i   [/o] /rFML      /i      /f[FML]  /i   [/o] end
89 inside:   |          |       |        |         |          |       |        |         |  
89 Labels    | chqpbtms | hbtms | hqbtms | btms    | chqpbtms | hbtms | hqbtms | btms    |  
89 meaning:  | topic    | topic | ed H   | topic   | topic    | topic | ed H   | topic   |  
90                                                                        /* isotopic only */
90                                                                        /* reversibility */
90                                                             FLAG_SORT_PRINT_NO_NFIX_H_REC;
90                                                             INCHI_IOSTREAM_STRING *strbuf,
90                                                     int *INCHI_basic_or_INCHI_reconnected,
90                                                     int *INCHI_basic_or_INCHI_reconnected,
90                                                     int *INCHI_basic_or_INCHI_reconnected,
90                                                    pINChI->StereoIsotopic->nCompInv2Abs &&
90                                                    pINChI->StereoIsotopic->nCompInv2Abs &&
90                                                   (bond_parityNM == AB_PARITY_EVEN)? "+" :
90                                                   (bond_parityNM == AB_PARITY_ODD)?  "-" :
90                                                   (bond_parityNM == AB_PARITY_UNKN)? "u" :
90                                        pINChI->StereoIsotopic->nNumberOfStereoCenters : 0;
90                                  bDisconnectedCoord, bOutputType, bINChIOutputOptionsCur, 
90                         /* inversion changes iso sp3 differently from non-iso sp3 Fix11 */
90                      chain_len  > 1 && j  > pnxt_atom ) {  /* j  is a cumulene endpoint */
90                     pr.bTautomeric        |= 1; /* tautomeric representation is present */
90                 /* search backward for the nearest first atom letter (always uppercase) */
90                 pr->tot_len = str_AuxInvIsoSp3Numb( pCG, pr->pINChISort, pr->pINChISort2, 
90             case OUT_T1: /* x[TAUT_YES]: tautomeric if present otherwise non-tautomeric */
90         Each of these options is a binary switch ON/OFF, so there are 2*2=4 combinations, 
90         if ( (val=needed_unusual_el_valence( at[j].el_number, at[j].charge, at[j].radical,
90         szGetTag( IdentLbl, pr->nTag,  pr->bTag1 = pr->bFhTag, pr->szTag1, &pr->bAlways );
90     int j, k, n, len, len0, cur_len, val, bonds_val, mw, parity, num_trans, is_ok, b_self;
90 	err = Output_INCHI_AUXINFO_get_cano_nums_and_compnt_nums_in_orig_nums_order( pCG, strbuf,
90 /* IL_REC__ORD, */    { "/r",  "reconnected bond(s) to metal(s) formula",  "formula",  0 }
91                                            &pr.bOverflow, pr.TAUT_MODE, pr.num_components);
91                                            pr->bOutType, pr->TAUT_MODE, pr->num_components,
91                                       orig_inp_data->szCoord, &i, szBuf, sizeof(szBuf) )) {
91                 if ( chain_len2 > 1 && j2 > pnxt_atom2  ) { /* j2 is a cumulene endpoint */
91                 szGetTag( AuxLbl, pr.nTag,  pr.bTag1 = pr.bFhTag, pr.szTag1, &pr.bAlways );
91         /* 1. Compare to tautomeric equivalence (in case of second, non-taut, pass only) */
91         /* 1. Compare to tautomeric equivalence (in case of second, non-taut, pass only) */
91         Note that anything but 'A' here would indicate "extended" InChI 1 Also, there is a 
91         The second character encodes experimental (InChI 1 extension) options KET and 15T. 
91     if ( pr->bOutType == OUT_NONTAUT && pr->bOutType == OUT_TN && pr->bSecondNonTautPass &&
91     Output AuxInfo: original atom numbers and symmetry numbers (constit. equivalence /E: )	
91 	if ( pr->tot_len != pr->tot_len2 ) { /* 2004-06-30: never output empty connection table */
91 	if ( pr->tot_len != pr->tot_len2 ) { /* 2004-06-30: never output empty connection table */
92                                                               INCHI_IOSTREAM_STRING *strbuf,
92                                                   (bond_parity == AB_PARITY_UNDF)? "?" : "",
92                                                  pINChI_Aux->nIsotopicOrigAtNosInCanonOrd &&
92                                              print_INCHI_local *pr, char *pLF, char *pTAB );
92                                    strbuf, &pr->bOverflow, pr->bOutType, pr->num_components,
92                                   (bINChIOutputOptions & INCHI_OUT_WINCHI_WINDOW) ? "\n":"",
92                                  bOutputType, INCHI_OUT_ONLY_AUX_INFO | bINChIOutputOptions,
92                                 const char *szSdfLabel, const char *szSdfValue, long lSdfId,
92                     num_trans = n; /* move this neighbor to 0 position permutation parity */
92                 case OUT_TN: /* x[TAUT_YES]: tautomeric if present otherwise non-tautomeric;
92                 memcpy( strbuf->pStr + strbuf->nUsedLength, p+cur_pos, last_pos - cur_pos );
92                 pr.tot_len = str_AuxTautTrans(nTrans_n, nTrans_s, pStr, nStrLen, pr.tot_len,
92              num_components2[INCHI_REC] && !(bINChIOutputOptions & INCHI_OUT_NO_AUX_INFO) ) 
92             if ( str_LineEnd( pr->szTag1, &pr->bOverflow, strbuf, -1, pr->bPlainTextTags ) )
92             if ( str_LineEnd( pr->szTag2, &pr->bOverflow, strbuf, -1, pr->bPlainTextTags ) )
92             if ( str_LineEnd( pr->szTag2, &pr->bOverflow, strbuf, -1, pr->bPlainTextTags ) )
92             if ( str_LineEnd( pr->szTag3, &pr->bOverflow, strbuf, -1, pr->bPlainTextTags ) )
92             inchi_ios_print( out_file, "%s%s", pr->szTag2, pLF ); /* mark isotopic output */
92          * Previous condition if( bHasIsotopicAtoms[pr->iCurTautMode] || bIsotopic && !bXml)
92         intermediate_result = Output_AUXINFO_original_numbers_and_equivalence_classes( pCG, 
92     intermediate_result = Output_INCHI_stereo_layer( pCG,out_file, strbuf, &pr, pLF, pTAB );
93                                                                             &pr, pLF, pTAB );
93                                                                 FLAG_SORT_PRINT_TRANSPOS_REC;
93                                                              FLAG_SORT_PRINT_NO_IFIX_H_REC ))
93                                                            &INCHI_basic_or_INCHI_reconnected,
93                                            &pnxt_atom2, &pinxt2cur2, &pinxt_sb_parity_ord2 );
93                                           sizeof(pINChI_Aux->nIsotopicOrigAtNosInCanonOrd[0])
93                                       (pINChI->StereoIsotopic->nNumberOfStereoCenters > 0 ) ?
93                         ; /* the requested non-tautomeric component is in tautomeric position
93                     /* does tautomeric structure have also a non-tautomeric repesentation? */
93                     for ( m1 = 0; m1 < MAX_NUM_STEREO_BONDS && at[j].sb_parity[m1]; m1 ++ ) {
93                 bCurIsoHStereo      = bCurIsoHPos && (bTautIsoHNum || bTautIsoAt) || bCurIso;
93                 const char *p_stereo = pr->bIsotopicRelativeStereo[pr->iCurTautMode]? x_rel :
93                 r = "iM";       /* inv stereo numb non-taut iso = InvStereo(main iso) numb */
93             /* if InChI Fixed-H isotopic is empty then do not output corresponding AuxInfo */
93         /* AuxInfo: original atom numbers and symmetry numbers (constit. equivalence /E: )	*/
93         intermediate_result = Output_AUXINFO_stereo( pCG, out_file, strbuf, &pr, pLF, pTAB );
93         pr->tot_len = str_HillFormula( pr->pINChISort, strbuf, &pr->bOverflow, pr->bOutType, 
93 			we used shallow (pointer) copy of analogs from orig_inp_data, so do not free these here */
93 /* IL_FMLF_ORD, */    { "/f",  "formula",        "formula",        1 }, /* fixed H formula */
94                                                                              &pr, pLF, pTAB );
94                                                                              num_components2, 
94                                                                             out_file, strbuf, 
94                                                                 FLAG_SORT_PRINT_NO_IFIX_H_REC;
94                                                             &INCHI_basic_or_INCHI_reconnected,
94                                                   (bond_parityNM == AB_PARITY_UNDF)? "?" : "",
94                                             &pr->bOverflow, pr->bOutType, pr->num_components);
94                                          strbuf, &pr->bOverflow, pr->bOutType, pr->TAUT_MODE, 
94                                       (pINChI->StereoIsotopic->nNumberOfStereoCenters > 1 ) &&
94                         pr.bTautomeric        |= 1; /* tautomeric representation is present */
94                     for ( m2 = 0; m2 < MAX_NUM_STEREO_BONDS && at[j2].sb_parity[m2]; m2 ++ ) {
94                 *pSortPrintINChIFlags |= (INCHI_BAS == iINChI)? FLAG_SORT_PRINT_TRANSPOS_BAS :
94                 case OUT_T1: /* x[TAUT_YES]: tautomeric if present otherwise non-tautomeric */
94                 if ( pr->bPlainTextTags == 1 ) inchi_ios_print( out_file, "/" ); /* iso sp2 */
94                 if ( str_LineEnd( pr.szTag1, &pr.bOverflow, strbuf, ind, pr.bPlainTextTags ) )
94                 r = "in";      /* inv stereo numb non-taut iso = InvStereo(non-taut) numb ) */
94     pr.pINChISortTautAndNonTaut = pINChISortTautAndNonTaut2[INCHI_basic_or_INCHI_reconnected];
94 		szGetTag( IdentLbl, pr->nTag,  pr->bTag1 = IL_STER | pr->bFhTag, pr->szTag1, &pr->bAlways );
95                                                                        /* inv abs sp3 stereo */
95                                                                  pOrigStruct, &pr, pLF, pTAB );
95                                                              &INCHI_basic_or_INCHI_reconnected,
95                 (*INCHI_basic_or_INCHI_reconnected==INCHI_BAS)?	FLAG_SORT_PRINT_NO_IFIX_H_BAS :
95                 (*INCHI_basic_or_INCHI_reconnected==INCHI_BAS)?	FLAG_SORT_PRINT_NO_NFIX_H_BAS :
95                 /* Fix08: missing isotopic inverted flag if isotopic = inverted non-isotopic */
95     pr->nSegmAction = INChI_SegmentAction( pr->sDifSegs[pr->nCurINChISegment][DIFS_q_CHARGE] );
95     pr->tot_len2 = str_Connections( pCG, pr->pINChISort, strbuf, &pr->bOverflow, pr->bOutType, 
95     pr->tot_len2 = str_Connections( pCG, pr->pINChISort, strbuf, &pr->bOverflow, pr->bOutType, 
95 			{ tmp = u->blist[ 2*k ] ; u->blist[ 2*k ] = u->blist[ 2*k+1 ] ; u->blist[ 2*k+1 ]  = tmp; 	}
95 int Output_INCHI_AUXINFO_get_cano_nums_and_compnt_nums_in_orig_nums_order( CANON_GLOBALS *pCG, 
96                                                                     /* isotopic mobile H only */
96                                                              FLAG_SORT_PRINT_NO_NFIX_H_REC )) &&
96                              process it also as non-tautomeric if Fixed-H layer was requested */
96                     pr.bAtomEqu[ii] |= (bCurEqu = bHasEquString( pINChI_Aux->nConstitEquNumbers,
96                 bTautomericAcid                 |= (0!=(pINChI->nFlags & INCHI_FLAG_ACID_TAUT));
96                 if ( (int)neigh == j && at[neigh].orig_at_number  ==  at[j].p_orig_at_num[n] ) {
96                 if ( str_LineEnd( pr->szTag3, &pr->bOverflow, strbuf, -1, pr->bPlainTextTags ) )
96 /* IL_FML__ORD, */    { "/",   "formula",        "formula",        1 }, /* basic part formula */
96 int WriteOrigCoord( int num_inp_atoms, MOL_COORD *szMolCoord, int *i, char *szBuf, int buf_len )
97                                                                                 &pr, pLF, pTAB );
97                                                                                 &pr, pLF, pTAB );
97                                                                                 num_components2, 
97                                                                             bINChIOutputOptions, 
97                                                                &INCHI_basic_or_INCHI_reconnected,
97                                          INCHI_IOSTREAM *out_file, INCHI_IOSTREAM_STRING *strbuf,
97                                  &pr->bOverflow, pr->bOutType, pr->TAUT_MODE, pr->num_components,
97                     for ( m = 0; m < MAX_NUM_STEREO_BONDS && at[pcur_atom].sb_parity[m]; m ++ ) {
97                     for ( m = 0; m < MAX_NUM_STEREO_BONDS && at[pcur_atom].sb_parity[m]; m ++ ) {
97                 bRequestedRacemicStereo         |= (0!=(pINChI->nFlags & INCHI_FLAG_RAC_STEREO));
97                 bRequestedRelativeStereo        |= (0!=(pINChI->nFlags & INCHI_FLAG_REL_STEREO));
97                 inchi_ios_print( out_file, "%s%s", strbuf->pStr, pr->bPlainTextTags? "" : "\n" );
97                 inchi_ios_print( out_file, "%s%s", strbuf->pStr, pr->bPlainTextTags? "" : "\n" );
97                 inchi_ios_print( out_file, "%s%s", strbuf->pStr, pr->bPlainTextTags? "" : "\n" );
97              at[j].charge || at[j].radical || at[j].iso_atw_diff || NUM_ISO_H(at,j) || parity ) {
97              bIsotopicStereo, bIsotopicStereoSp2, bIsotopicStereoSp3, bIsotopicStereoAbsInverted 
97             /* output the second non-tautomeric item: fixed H -- do not output in xml if empty */
97         INCHI_OUT_EMBED_REC             0x0008    embed reconnected INChI into disconnected INChI
97         szGetTag( AuxLbl, pr->nTag,  pr->bTag2 = pr->bTag1 | AL_ATMR, pr->szTag2, &pr->bAlways );
97         szGetTag( AuxLbl, pr->nTag,  pr->bTag2 = pr->bTag1 | AL_BNDR, pr->szTag2, &pr->bAlways );
97         szGetTag( AuxLbl, pr->nTag,  pr->bTag2 = pr->bTag1 | AL_ISON, pr->szTag2, &pr->bAlways );
97         szGetTag( AuxLbl, pr->nTag,  pr->bTag2 = pr->bTag1 | AL_SP3I, pr->szTag2, &pr->bAlways );
97         szGetTag( AuxLbl, pr->nTag,  pr->bTag2 = pr->bTag1 | AL_XYZR, pr->szTag2, &pr->bAlways );
97     pr.sDifSegs[DIFL_MI][DIFS_h_H_ATOMS] = bHasIsoH?           DIFV_NEQ2PRECED : DIFV_BOTH_EMPTY;
98                                                                                 out_file, strbuf, 
98                                                                                 out_file, strbuf, 
98                                                                     FLAG_SORT_PRINT_NO_IFIX_H_REC;
98                                                                     FLAG_SORT_PRINT_NO_NFIX_H_REC;
98                         len += sprintf( szCurAtom + len, "%s%c", len == len0? ".":"", szIsoH[k] );
98         int bCurStereoSp2, bCurIsoStereoSp2, bCurStereoSp3, bCurIsoStereoSp3, bCurIsoStereoSp3Inv;
98         intermediate_result = Output_AUXINFO_header_and_normalization_type( pCG, out_file, strbuf,
98         szGetTag( AuxLbl, pr->nTag,  pr->bTag1 = AL_AEQU | pr->bFhTag, pr->szTag1, &pr->bAlways );
98         szGetTag( AuxLbl, pr->nTag,  pr->bTag1 = AL_CRV_ | pr->bFhTag, pr->szTag1, &pr->bAlways );
98         szGetTag( AuxLbl, pr->nTag,  pr->bTag1 = AL_GEQU | pr->bFhTag, pr->szTag1, &pr->bAlways );
98         szGetTag( AuxLbl, pr->nTag,  pr->bTag1 = AL_ISOT | pr->bFhTag, pr->szTag1, &pr->bAlways );
98         szGetTag( AuxLbl, pr->nTag,  pr->bTag1 = AL_REVR | pr->bFhTag, pr->szTag1, &pr->bAlways );
98         szGetTag( AuxLbl, pr->nTag,  pr->bTag1 = AL_STER | pr->bFhTag, pr->szTag1, &pr->bAlways );
99                                   orig_inp_data->at, &i, pOrigStruct->szAtoms, len_atoms+1, sd ) &&
99                                   orig_inp_data->at, &i, pOrigStruct->szBonds, len_bonds+2, sd ) &&
99                                  pr->bSecondNonTautPass, pr->bOmitRepetitions, pr->bUseMulipliers);
99                     ((INCHI_basic_or_INCHI_reconnected==INCHI_BAS)? FLAG_SORT_PRINT_NO_NFIX_H_BAS :
99                 ( *INCHI_basic_or_INCHI_reconnected == INCHI_BAS )?  FLAG_SORT_PRINT_TRANSPOS_BAS :
99                 bCurStereoSp2       = pINChI->Stereo && (pINChI->Stereo->nNumberOfStereoBonds > 0);
99             (pr->tot_len) += MakeIsoHString( pr->num_iso_H, strbuf, pr->TAUT_MODE, &pr->bOverflow);
99             /* isotopic #5: stereo type. Do not output if it has already been output in non-iso */ 
99             strcpy( szTag, nTag == 1? Tag[j].szXmlLabel : nTag == 2? Tag[j].szPlainLabel : "???" );
99     pOrigStruct->szAtoms = (char*) inchi_malloc( (len_atoms + 1)*sizeof(pOrigStruct->szAtoms[0]) );
99     pOrigStruct->szBonds = (char*) inchi_malloc( (len_bonds + 2)*sizeof(pOrigStruct->szBonds[0]) );
100                                 bond_parity = 2 - (p1 + p2 + bNeighSwitched1 + bNeighSwitched2) % 2;
100                     int bCurEqu, bCurTautEqu=0, bCurIsoEqu=0, bCurIsoTautEqu=0; /* Fix15-disabled */
100         pr->nSegmAction = INChI_SegmentAction( pr->sDifSegs[pr->nCurINChISegment][DIFS_f_FORMULA] );
100         pr->nSegmAction = INChI_SegmentAction( pr->sDifSegs[pr->nCurINChISegment][DIFS_h_H_ATOMS] );
100         pr->nSegmAction = INChI_SegmentAction( pr->sDifSegs[pr->nCurINChISegment][DIFS_p_PROTONS] );
100         szGetTag( IdentLbl, pr->nTag,  pr->bTag1 = IL_CHRG | pr->bFhTag, pr->szTag1, &pr->bAlways );
100         szGetTag( IdentLbl, pr->nTag,  pr->bTag1 = IL_FMLF | pr->bFhTag, pr->szTag1, &pr->bAlways );
100         szGetTag( IdentLbl, pr->nTag,  pr->bTag1 = IL_ISOT | pr->bFhTag, pr->szTag1, &pr->bAlways );
100     if ( pr.bTautomeric /*&& bTautomericAcid*/ ) /* "&& bTautomericAcid" commented out 2004-06-02 */
100     pr.sDifSegs[DIFL_M ][DIFS_p_PROTONS] = pr.nNumRemovedProtons? DIFV_NEQ2PRECED : DIFV_BOTH_EMPTY;
100 /* AL_FIXH_ORD, */    { "/",     "fixed_H",                "fixed-H",             0 }, /* fixed-H */
101                                                                         FLAG_SORT_PRINT_TRANSPOS_REC;
101                                                    &pr->bOverflow, pr->bOutType, pr->num_components);
101                                        pr->bIsotopicRelativeStereo[pr->iCurTautMode] ? x_rac : x_abs;
101                                      &pr->bOverflow, pr->bOutType, pr->TAUT_MODE, pr->num_components,
101                                    pr->bSecondNonTautPass, pr->bOmitRepetitions, pr->bUseMulipliers);
101                                    pr->bSecondNonTautPass, pr->bOmitRepetitions, pr->bUseMulipliers);
101                             AddErrorMessage(sd->pStrErrStruct, "Cannot find 0D stereobond neighbor");
101                             AddErrorMessage(sd->pStrErrStruct, "Cannot find 0D stereobond neighbor");
101                 if ( str_LineEnd( :p_aux_at_inv_nbr, &pr.bOverflow, strbuf, -1, pr.bPlainTextTags ) )
101             szGetTag( AuxLbl, pr->nTag,  pr->bTag2 = pr->bTag1 | AL_AEQU, pr->szTag2, &pr->bAlways );
101             szGetTag( AuxLbl, pr->nTag,  pr->bTag2 = pr->bTag1 | AL_GEQU, pr->szTag2, &pr->bAlways );
101             szGetTag( AuxLbl, pr->nTag,  pr->bTag2 = pr->bTag1 | AL_SP3N, pr->szTag2, &pr->bAlways );
101             szGetTag( AuxLbl, pr->nTag,  pr->bTag2 = pr->bTag1 | AL_STER, pr->szTag2, &pr->bAlways );
101             szGetTag( AuxLbl, pr->nTag,  pr->bTag3 = pr->bTag2 | AL_SP3I, pr->szTag3, &pr->bAlways );
101 	if ( INCHI_SEGM_FILL == INChI_SegmentAction( pr->sDifSegs[pr->nCurINChISegment][DIFS_h_H_ATOMS] ) ) 
101 	if ( INCHI_SEGM_FILL == INChI_SegmentAction( pr->sDifSegs[pr->nCurINChISegment][DIFS_h_H_ATOMS] ) ) 
101 /* AL_ISOT_ORD, */    { "/",     "isotopic",               "isotopic",            0 }, /* isotopic */
101 /* IL_TYPS_ORD, */    { "/s",  "type (1=abs, 2=rel, 3=rac)", "type",           0 }, /* stereo type */
101 static int Output_INCHI_AUXINFO_get_cano_nums_and_compnt_nums_in_orig_nums_order(CANON_GLOBALS *pCG, 
102                                  at[j].chem_bonds_valence, bonds_val, at[j].num_H, at[j].valence )) ||
102                         /* non-zero if isotopic numbering for inverted isotopic stereo is different */
102                    pr.bOutType == OUT_NT? TAUT_NON:  /* only non-taut representations of tautomeric */
102                 bCurStereoSp3       = pINChI->Stereo && (pINChI->Stereo->nNumberOfStereoCenters > 0 );
102                 jj = ( j == TAUT_YES )? GET_II(OUT_T1,is) : ( j == TAUT_NON )? GET_II(OUT_NT,is) : -1;
102             pr.bNonTautomeric = 0; /* bNonTautIdentifierNotEmpty == 0 => no fixed H info 02-10-2995 */
102         if ( str_LineEnd( pr->szTag1, &pr->bOverflow, strbuf, -pr->nSegmAction, pr->bPlainTextTags ) )
102         if ( str_LineEnd( pr->szTag1, &pr->bOverflow, strbuf, -pr->nSegmAction, pr->bPlainTextTags ) )
102     Output InChI: main layer - formula, connections and hydrogens (incl. tautomeric info == mobile H) 
103                                                                     &INCHI_basic_or_INCHI_reconnected, 
103                                      pr->bSecondNonTautPass, pr->bOmitRepetitions, pr->bUseMulipliers);
103                             (!num_components2[0] && !num_components2[1])? "//":"", /* empty InChI=// */
103                 bStereoAbsInverted[ii]          |= bCurStereoSp3 && (pINChI->Stereo->nCompInv2Abs < 0);
103             inchi_ios_print( out_file, "%s\n", (!num_components2[0] && !num_components2[1])? "//":"" );
103             szGetTag( IdentLbl, pr->nTag,  pr->bTag2 = pr->bTag1 | IL_ATMS, pr->szTag2, &pr->bAlways );
103             szGetTag( IdentLbl, pr->nTag,  pr->bTag2 = pr->bTag1 | IL_DBND, pr->szTag2, &pr->bAlways );
103             szGetTag( IdentLbl, pr->nTag,  pr->bTag2 = pr->bTag1 | IL_INVS, pr->szTag2, &pr->bAlways );
103             szGetTag( IdentLbl, pr->nTag,  pr->bTag2 = pr->bTag1 | IL_SP3S, pr->szTag2, &pr->bAlways );
103             szGetTag( IdentLbl, pr->nTag,  pr->bTag2 = pr->bTag1 | IL_STER, pr->szTag2, &pr->bAlways );
103             szGetTag( IdentLbl, pr->nTag,  pr->bTag2 = pr->bTag1 | IL_TYPS, pr->szTag2, &pr->bAlways );
103             szGetTag( IdentLbl, pr->nTag,  pr->bTag2 = pr->bTag1 | IL_XCGA, pr->szTag2, &pr->bAlways );
103         /***** constitution non-taut: dot-disconnected Hill formulas: <formula> -- only if different */
103         int bCurIso, bCurStereo, bCurIsoStereo, bCurHasIsoStereo /* Fix14 */, bCurTaut /*, bCurTaut2*/;
103         pOrigStruct->szCoord = (char*) inchi_malloc( (len_coord + 1)*sizeof(pOrigStruct->szCoord[0]) );
104                                                                     &pr, pLF, pTAB, &then_goto_repeat );
104                                                           pINChI_Aux->nIsotopicOrigAtNosInCanonOrdInv &&
104                                       orig_inp_data->szCoord, &i, pOrigStruct->szCoord, len_coord+1 ) &&
104                         pr.bInvIsotopicStereoOrigNumb[ii] |= pINChI_Aux->nIsotopicOrigAtNosInCanonOrd &&
104                 bStereoAbs[ii]                  |= bCurStereoSp3 && (pINChI->Stereo->nCompInv2Abs != 0);
104             if (str_LineEnd( pr->szTag2, &pr->bOverflow, strbuf, -pr->nSegmAction, pr->bPlainTextTags ))
104             if (str_LineEnd( pr->szTag2, &pr->bOverflow, strbuf, -pr->nSegmAction, pr->bPlainTextTags ))
104             if (str_LineEnd( pr->szTag2, &pr->bOverflow, strbuf, -pr->nSegmAction, pr->bPlainTextTags ))
104             szGetTag( IdentLbl, pr->nTag,  pr->bTag1 = IL_HFIX | pr->bFhTag, pr->szTag1, &pr->bAlways );
104             szGetTag( IdentLbl, pr->nTag,  pr->bTag1 = IL_PROT | pr->bFhTag, pr->szTag1, &pr->bAlways );
104             szGetTag( IdentLbl, pr->nTag,  pr->bTag1 = IL_TRNS | pr->bFhTag, pr->szTag1, &pr->bAlways );
104         if ( pr->nSegmAction = INChI_SegmentAction( pr->sDifSegs[pr->nCurINChISegment][DIFS_s_STYPE] ) )
104     if ( INCHI_basic_or_INCHI_reconnected == INCHI_BAS || !(bINChIOutputOptions & INCHI_OUT_EMBED_REC)) 
104     int j, k, k2, kk, len, cur_len, j2=0, bond_stereo, bond_char, bond_parity, bond_parityNM, num_trans;
104 const char x_aux_comm[]       = "!-- This section is NOT a part of the identifier, it is not unique --";
105                                                  INCHI_IOSTREAM *out_file, INCHI_IOSTREAM_STRING *strbuf,
105                 szGetTag( AuxLbl, pr->nTag,  pr->bTag3 = pr->bTag2 | AL_SP3N, pr->szTag3, &pr->bAlways );
105         if ( pr->bTautomericOutputAllowed && pr->bTautomeric && pr->bIsotopicTautEqu[pr->iCurTautMode] ) 
105         if ( pr->nSegmAction = INChI_SegmentAction( pr->sDifSegs[pr->nCurINChISegment][DIFS_b_SBONDS] ) )
105         if ( pr->nSegmAction = INChI_SegmentAction( pr->sDifSegs[pr->nCurINChISegment][DIFS_i_IATOMS] ) )
105         if ( pr->nSegmAction = INChI_SegmentAction( pr->sDifSegs[pr->nCurINChISegment][DIFS_m_SP3INV] ) )
105         if ( pr->nSegmAction = INChI_SegmentAction( pr->sDifSegs[pr->nCurINChISegment][DIFS_t_SATOMS] ) )
105         Output_INCHI_version_and_kind( out_file, strbuf, bINChIOutputOptions, nAtomsAllComp, pLF, pTAB );
105         pr->bOutType     = OUT_NONTAUT;    /* pick up only non-tautomeric representation of tautomeric */
106                                         pr->bSecondNonTautPass, pr->bOmitRepetitions, pr->bUseMulipliers);
106                                     sepatately output non-taut representations of tautomeric if present */
106                                 bond_parityNM = 2 - (p1NM + p2NM + bNeighSwitched1 + bNeighSwitched2) % 2;
106                     jj = ( j == TAUT_YES )? GET_II(OUT_T1,is) : ( j == TAUT_NON )? GET_II(OUT_NT,is) : -1;
106                    pr.bOutType == OUT_T1? TAUT_YES:  /* tautomeric if present, otherwise non-tautomeric */
106                    pr.bOutType == OUT_TN? TAUT_YES:  /* tautomeric if present otherwise non-tautomeric; */
106                 bHardAddRemProton               |= (0!=(pINChI->nFlags & INCHI_FLAG_HARD_ADD_REM_PROTON));
106                 num_trans += insertions_sort( pCG, nNeighOrder, k, sizeof(nNeighOrder[0]), comp_AT_RANK );
106             if ( str_LineEnd( pr->szTag1, &pr->bOverflow, strbuf, -pr->nSegmAction, pr->bPlainTextTags ) )
106             if ( str_LineEnd( pr->szTag1, &pr->bOverflow, strbuf, -pr->nSegmAction, pr->bPlainTextTags ) )
106             if ( str_LineEnd( pr->szTag2, &pr->bOverflow, strbuf, -pr->nSegmAction, pr->bPlainTextTags ) )
106             if ( str_LineEnd( pr->szTag2, &pr->bOverflow, strbuf, -pr->nSegmAction, pr->bPlainTextTags ) )
106             if ( str_LineEnd( pr->szTag2, &pr->bOverflow, strbuf, -pr->nSegmAction, pr->bPlainTextTags ) )
106         if ( pr->nSegmAction = INChI_SegmentAction( pr->sDifSegs[pr->nCurINChISegment][DIFS_h_H_ATOMS] ) )
106 /* AL_REVR_ORD, */    { "/",     "reversibility",          "reversibility",       0 }, /* reversibility */
107                                                                pINChI_Aux->nNumberOfAtoms)) /*|| bCurEqu*/;
107                 bCurIsoRacemic      = bRequestedRacemicStereo && (bCurIsoStereoSp3 || bCurIsoStereoSp3Inv);
107                 if ( !(bINChIOutputOptions & INCHI_OUT_NO_AUX_INFO) && (pINChI_Aux = is->pINChI_Aux[jj]) ) 
107                 pr.bIgn_UU_Sp2[ii]        |= !bCurStereoSp2 && (pINChI->nFlags & INCHI_FLAG_SB_IGN_ALL_UU);
107                 pr.bIgn_UU_Sp3[ii]        |= !bCurStereoSp3 && (pINChI->nFlags & INCHI_FLAG_SC_IGN_ALL_UU);
107                 szGetTag( IdentLbl, pr->nTag,  pr->bTag3 = pr->bTag2 | IL_DBND, pr->szTag3, &pr->bAlways );
107                 szGetTag( IdentLbl, pr->nTag,  pr->bTag3 = pr->bTag2 | IL_INVS, pr->szTag3, &pr->bAlways );
107                 szGetTag( IdentLbl, pr->nTag,  pr->bTag3 = pr->bTag2 | IL_SP3S, pr->szTag3, &pr->bAlways );
107                 szGetTag( IdentLbl, pr->nTag,  pr->bTag3 = pr->bTag2 | IL_TYPS, pr->szTag3, &pr->bAlways );
108                                           pr->bSecondNonTautPass, pr->bOmitRepetitions, pr->bUseMulipliers);
108                 bCurIsoRelative     = bRequestedRelativeStereo && (bCurIsoStereoSp3 || bCurIsoStereoSp3Inv);
108                 case OUT_NT: /* x[TAUT_NON]: only non-taut representations of tautomeric -- never happens */
108             if ( pr->nSegmAction = INChI_SegmentAction( pr->sDifSegs[pr->nCurINChISegment][DIFS_s_STYPE] ) )
108             pr->bRelRac     = pr->bRelativeStereo[pr->iCurTautMode] || pr->bRacemicStereo[pr->iCurTautMode];
108         nMaxLineLen = inchi_min( 80, strbuf->nAllocatedLength ); /* restrict line length to 80 characters */
108     int  bPlainText			= 0 != (bINChIOutputOptions & (INCHI_OUT_PLAIN_TEXT | INCHI_OUT_PLAIN_TEXT_COMMENTS));
109                                   /* blank line before AuxInfo in winchi window unless it is an annotation */
109                     jj2 = ( j == TAUT_YES )? GET_II(OUT_T1,is2) : ( j == TAUT_NON )? GET_II(OUT_NT,is2) : -1;
109                 k2 = (int) (is_in_the_list( at[j2].neighbor, (AT_NUMB)j, at[j2].valence ) - at[j2].neighbor);
109             if ( pr->nSegmAction = INChI_SegmentAction( pr->sDifSegs[pr->nCurINChISegment][DIFS_b_SBONDS] ) )
109             if ( pr->nSegmAction = INChI_SegmentAction( pr->sDifSegs[pr->nCurINChISegment][DIFS_m_SP3INV] ) )
109             if ( pr->nSegmAction = INChI_SegmentAction( pr->sDifSegs[pr->nCurINChISegment][DIFS_t_SATOMS] ) )
109             if ( str_LineEnd( pr->szTag2, &pr->bOverflow, strbuf, -2/*was -1: Fix15*/, pr->bPlainTextTags ) )
109             if ( str_LineEnd( pr->szTag2, &pr->bOverflow, strbuf, -2/*was -1: Fix15*/, pr->bPlainTextTags ) )
109             num_trans = insertions_sort( pCG, nNeighOrder, at[j].valence, sizeof(nNeighOrder[0]), CompRank );
109         if ( pr->bPlainTextTags == 1 ) inchi_ios_print( out_file, "/" );  /* no abs, inv or racemic stereo */
109     int bINChIOutputOptions0 = bINChIOutputOptions & ~(INCHI_OUT_PLAIN_TEXT | INCHI_OUT_PLAIN_TEXT_COMMENTS);
110                         pr.bTautEqu[ii] |= (bCurTautEqu = bHasEquString( pINChI_Aux->nConstitEquTGroupNumbers,
110                 if ( str_LineEnd( pr->szTag3, &pr->bOverflow, strbuf, -pr->nSegmAction, pr->bPlainTextTags ) )
110                 if ( str_LineEnd( pr->szTag3, &pr->bOverflow, strbuf, -pr->nSegmAction, pr->bPlainTextTags ) )
110                 if ( str_LineEnd( pr->szTag3, &pr->bOverflow, strbuf, -pr->nSegmAction, pr->bPlainTextTags ) )
110                 if ( str_LineEnd( pr->szTag3, &pr->bOverflow, strbuf, -pr->nSegmAction, pr->bPlainTextTags ) )
110             if ( pr.bOutType == OUT_NONTAUT && bOutputType == OUT_TN && pr.bTautomeric && pr.bNonTautomeric ) 
111                                                                              &INCHI_basic_or_INCHI_reconnected,
111                                                                   /* prefixes: may be combined in this order */
111 /* AL_STER_ORD, */    { "/",     "abs_stereo_inverted",    "stereo.abs.inverted", 0 }, /* inv abs sp3 stereo */
112                                                                     /* prefixes may be combined in this order */
112                     bTautIsoAt   += (pINChI->nNumberOfIsotopicAtoms>0 || pINChI->nNumberOfIsotopicTGroups > 0 );
112         if ( pr->bPlainTextTags == 1 ) inchi_ios_print( out_file, "////" ); /* sp3, sp2, abs-inv, stereo.type */
113                        && ( pr->bIgn_UU_Sp3_Iso[pr->iCurTautMode] || pr->bIgn_UU_Sp2_Iso[pr->iCurTautMode] ) ) ) 
113                     len = last+1+sprintf( szVal+last+1, "%d", e ); /* print exp without leading zeroes and '+' */
113     int  bPlainText        = 0 != (bINChIOutputOptions & (INCHI_OUT_PLAIN_TEXT | INCHI_OUT_PLAIN_TEXT_COMMENTS));
114                                           strbuf, &pr->bOverflow, pr->bOutType, pr->TAUT_MODE, pr->num_components,
114                     if ( pINChI_Aux->OrigInfo && bHasOrigInfo(pINChI_Aux->OrigInfo, pINChI_Aux->nNumberOfAtoms) ) 
114                  pr->bTag1 = (pr->bSecondNonTautPass? AL_FIXN : AL_ANBR) | pr->bFhTag, pr->szTag1, &pr->bAlways );
114                 bCurIso             = (pINChI->nNumberOfIsotopicAtoms>0 || pINChI->nNumberOfIsotopicTGroups > 0 );
114                 pr.bIgn_UU_Sp2_Iso[ii]    |= !bCurIsoStereoSp2 && (pINChI->nFlags & INCHI_FLAG_SB_IGN_ALL_ISO_UU);
114                 pr.bIgn_UU_Sp3_Iso[ii]    |= !bCurIsoStereoSp3 && (pINChI->nFlags & INCHI_FLAG_SC_IGN_ALL_ISO_UU);
114             /* pr.bIsotopicRelativeStereo[i]=0 may happen because iso stereo is same or inverted non-iso stereo */
115                                                                                   FLAG_SORT_PRINT_NO_IFIX_H_REC ));
115                        pr->bTautomericOutputAllowed && pr->bTautomeric && pr->bIsotopicTautEqu[pr->iCurTautMode] ||
115                     bCurIsoStereoSp3 = !Eql_INChI_Stereo( pINChI->Stereo, EQL_SP3, pINChI->StereoIsotopic, EQL_SP3,
116                                     /* || pr->iCurTautMode == TAUT_YES && num_comp[TAUT_YES] < num_comp[TAUT_NON] &&
116                 bIsotopicStereoAbsInverted[ii]  |= bCurIsoStereoSp3 && (pINChI->StereoIsotopic->nCompInv2Abs < 0) ||
116                 if ( (pINChI = is->pINChI[jj]) && pINChI->nNumberOfAtoms > 0 && (pINChI_Aux = is->pINChI_Aux[jj]) ) 
116             (*pSortPrintINChIFlags & ((INCHI_basic_or_INCHI_reconnected==INCHI_BAS)? FLAG_SORT_PRINT_NO_IFIX_H_BAS :
116             (*pSortPrintINChIFlags & ((INCHI_basic_or_INCHI_reconnected==INCHI_BAS)? FLAG_SORT_PRINT_NO_NFIX_H_BAS :
116         inchi_strbuf_printf( strbuf, "%d", (pr->bTautomeric && pr->bTautomericOutputAllowed)? pr->bTautomeric : 0); 
117                                                                    pINChI_Aux->nNumberOfTGroups)) /*|| bCurTautEqu*/;
117                                                    !bCurIsoStereoSp3  && pINChI->StereoIsotopic  && pINChI->Stereo &&
117                                                    !bCurIsoStereoSp3  && pINChI->StereoIsotopic  && pINChI->Stereo &&
117                               (pINChI->nFlags & INCHI_FLAG_RAC_STEREO) || (pINChI->nFlags & INCHI_FLAG_REL_STEREO) );
117                 bIsotopicStereoAbs[ii]          |= bCurIsoStereoSp3 && (pINChI->StereoIsotopic->nCompInv2Abs != 0) ||
117         Output_record_info( out_file, num_input_struct, bNoStructLabels, szSdfLabel, szSdfValue, lSdfId, pLF, pTAB );
118                         bCurIsoStereoSp3Inv &= (pINChI->StereoIsotopic->nCompInv2Abs != pINChI->Stereo->nCompInv2Abs);
118          (*pr->pSortPrintINChIFlags & ((*INCHI_basic_or_INCHI_reconnected==INCHI_BAS)? FLAG_SORT_PRINT_NO_IFIX_H_BAS :
118     pr.bPlainTextTags    = 2;  /* 0 => no plain tags, 1=> plain text tags, 2=>plaintext tags without consecutive // */
119                         pr.bIsotopicAtomEqu[ii] |= (bCurIsoEqu = bHasEquString( pINChI_Aux->nConstitEquIsotopicNumbers,
119                 /* check whether isotopic stereo is same as non-isotopic; if same than do not output isotopic stereo */
119                 ii = j; /* ii is what we wanted; jj is what we found (0 = TAUT_NON: fixed_H, 1 = TAUT_YES: mobile_H) */
120                                                    pINChI->StereoIsotopic->nCompInv2Abs != pINChI->Stereo->nCompInv2Abs;
120                                                    pINChI->StereoIsotopic->nCompInv2Abs != pINChI->Stereo->nCompInv2Abs;
120                     bCurIsoStereoSp2 = !Eql_INChI_Stereo( pINChI->Stereo, EQL_SP2, pINChI->StereoIsotopic, EQL_SP2, 0 );
120         inchi_strbuf_printf( strbuf, "AuxInfo=" ); /* in wINChI window, separate INChI: from AuxInfo: with blank line */
120     if ( pr->bTautomericOutputAllowed && pr->bTautomeric && pr->bTautEqu[pr->iCurTautMode] && !pr->bSecondNonTautPass ) 
124                                              -1;   /* separately output non-taut representations of tautomeric if present */
125                 pr->bRelRac = pr->bIsotopicRelativeStereo[pr->iCurTautMode] || pr->bIsotopicRelativeStereo[pr->iCurTautMode];
126                 (*pr->pSortPrintINChIFlags) |= (*INCHI_basic_or_INCHI_reconnected==INCHI_BAS)? FLAG_SORT_PRINT_NO_IFIX_H_BAS :
126                 (*pr->pSortPrintINChIFlags) |= (*INCHI_basic_or_INCHI_reconnected==INCHI_BAS)? FLAG_SORT_PRINT_NO_NFIX_H_BAS :
126         if ( 0 < bin_AuxTautTrans(pr->pINChISort, pr->pINChISort2, &nTrans_n, &nTrans_s, pr->bOutType,  pr->num_components) ) 
128             if ( 0 < bin_AuxTautTrans( pr.pINChISort, pr.pINChISort2, &nTrans_n, &nTrans_s, pr.bOutType,  pr.num_components) ) {
128         /*if ( pr->bRacemicStereo[pr->iCurTautMode] || pr->bRelativeStereo[pr->iCurTautMode] || bStereoAbs[pr->iCurTautMode] )*/
130                              bNeighSwitched1 = (neigh1 != at[pcur_atom].neighbor[(int)at[pcur_atom].sn_ord[picur_sb_parity_ord]]);
130                              bNeighSwitched2 = (neigh2 != at[pnxt_atom].neighbor[(int)at[pnxt_atom].sn_ord[pinxt_sb_parity_ord]]);
130                 bCurIsoStereoSp3Inv = bCurIsoStereoSp3 && pINChI->StereoIsotopic->nCompInv2Abs; /* inversion changes sp3 stereo */
130         if ( bDisconnectedCoord && INCHI_basic_or_INCHI_reconnected == INCHI_BAS && (bINChIOutputOptions & INCHI_OUT_EMBED_REC) &&
131                     bCurStereoSp3     = bCurRelative || bCurStereoSp3 && (pINChI->Stereo->nNumberOfStereoCenters > 1 ); /* Fix11 */
133                             pr.bIsotopicTautEqu[ii] |= (bCurIsoTautEqu = bHasEquString( pINChI_Aux->nConstitEquIsotopicTGroupNumbers,
133                 bCurIsoStereoSp2    = bCurIsoHStereo && pINChI->StereoIsotopic && (pINChI->StereoIsotopic->nNumberOfStereoBonds > 0);
135                 bCurIsoStereoSp3    = bCurIsoHStereo && pINChI->StereoIsotopic && (pINChI->StereoIsotopic->nNumberOfStereoCenters > 0);
136                     /* bCurIsoStereoSp3=0 means (iso stereo sp3) = (non-iso stereo sp3) or (iso stereo sp3) = Inv(non-iso stereo sp3) */
141                         bCurStereoSp3     = bCurRacemic    > 1 || bCurStereoSp3 && (pINChI->Stereo->nNumberOfStereoCenters > 1 ); /* Fix11 */
141         if ( pr->bOutType == OUT_NONTAUT && pr->bOutType == OUT_TN && pr->bSecondNonTautPass /* && pr->bTautomeric && pr->bNonTautomeric*/ ) 
143         szGetTag( IdentLbl, pr->nTag,  pr->bTag1 = *INCHI_basic_or_INCHI_reconnected==INCHI_REC? IL_REC_ : IL_FML_, pr->szTag1, &pr->bAlways );
148         pr->num_components = pr->num_comp[pr->iCurTautMode]; /* number of components could change due to removal of isolated H(+) from tautomeric */
149     char szCurBonds[7*MAXVAL+2]; /* num_neigh*(1 byte bond type + 2 bytes for bond parity up to 4 digits per neighbor number) + at the end one ';' */
153                 bCurIsoHPos         = (pINChI->nPossibleLocationsOfIsotopicH && pINChI->nPossibleLocationsOfIsotopicH[0] > 1 || pINChI->lenTautomer > 1);
571     /* InChI output: atoms */																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																														
809         ( bINChIOutputOptions & INCHI_OUT_SAVEOPT )		&&																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																		
